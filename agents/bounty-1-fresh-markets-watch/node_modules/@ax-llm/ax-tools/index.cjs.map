{"version":3,"sources":["../mcp/stdioTransport.ts","../functions/jsInterpreter.ts"],"names":["AxMCPStdioTransport","config","spawn","readline","line","response","resolver","message","resolve","res"],"mappings":"AAAA,ylBAA2D,wFACtC,IAeRA,CAAAA,WAAN,KAAoD,CACjD,eAEA,gBAAA,CAAmB,IAAI,IAAA,WAK/B,CAAYC,CAAAA,CAAwC,qCAClD,IAAA,CAAK,OAAA,CAAUC,kCAAAA,CAAMD,CAAO,OAAA,kBAASA,CAAAA,CAAO,IAAA,SAAQ,CAAC,GAAA,CAAG,CACtD,GAAA,CAAKA,CAAAA,CAAO,GAAA,CAAM,CAAE,GAAG,OAAA,CAAQ,GAAA,CAAK,GAAGA,CAAAA,CAAO,GAAI,CAAA,CAAI,OAAA,CAAQ,GAChE,CAAC,CAAA,CACD,IAAA,CAAK,EAAA,CAAKE,kBAAAA,CAAS,eAAA,CAAgB,CAAE,KAAA,CAAO,IAAA,CAAK,OAAA,CAAQ,MAAO,CAAC,CAAA,CACjE,IAAA,CAAK,EAAA,CAAG,EAAA,CAAG,MAAA,CAASC,CAAAA,EAAS,CAC3B,GAAI,CACF,IAAMC,CAAAA,CAAiC,IAAA,CAAK,KAAA,CAAMD,CAAI,CAAA,CAChDE,CAAAA,CAAW,IAAA,CAAK,gBAAA,CAAiB,GAAA,CAAID,CAAAA,CAAS,EAAE,CAAA,CAClDC,CAAAA,EAAAA,CACFA,CAAAA,CAASD,CAAQ,CAAA,CACjB,IAAA,CAAK,gBAAA,CAAiB,MAAA,CAAOA,CAAAA,CAAS,EAAE,CAAA,CAE5C,CAAA,UAAiB,CAEf,OAAA,CAAQ,IAAA,CAAK,kCAAA,CAAoCD,CAAI,CACvD,CACF,CAAC,CACH,CAEA,MAAM,IAAA,CACJG,CAAAA,CACwC,CACxC,OAAO,IAAI,OAAA,CAAwCC,CAAAA,EAAY,CAC7D,IAAA,CAAK,gBAAA,CAAiB,GAAA,CAAID,CAAAA,CAAQ,EAAA,CAAKE,CAAAA,EAA8B,CACnED,CAAAA,CAAQC,CAAoC,CAC9C,CAAC,CAAA,CACD,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,KAAA,CAAM,CAAA,EAAA;AAOwB;AC5CnD","file":"/home/runner/work/ax/ax/src/tools/dist/index.cjs","sourcesContent":["import { type ChildProcessWithoutNullStreams, spawn } from 'node:child_process';\nimport readline from 'node:readline';\n\nimport type {\n  AxMCPJSONRPCNotification,\n  AxMCPJSONRPCRequest,\n  AxMCPJSONRPCResponse,\n  AxMCPTransport,\n} from '@ax-llm/ax';\n\nexport interface StdioTransportConfig {\n  command: string;\n  args?: string[];\n  env?: NodeJS.ProcessEnv;\n}\n\nexport class AxMCPStdioTransport implements AxMCPTransport {\n  private process: ChildProcessWithoutNullStreams;\n  private rl: readline.Interface;\n  private pendingResponses = new Map<\n    string | number,\n    (res: AxMCPJSONRPCResponse) => void\n  >();\n\n  constructor(config: Readonly<StdioTransportConfig>) {\n    this.process = spawn(config.command, config.args ?? [], {\n      env: config.env ? { ...process.env, ...config.env } : process.env,\n    });\n    this.rl = readline.createInterface({ input: this.process.stdout });\n    this.rl.on('line', (line) => {\n      try {\n        const response: AxMCPJSONRPCResponse = JSON.parse(line);\n        const resolver = this.pendingResponses.get(response.id);\n        if (resolver) {\n          resolver(response);\n          this.pendingResponses.delete(response.id);\n        }\n      } catch (_error) {\n        // Skip non-JSON lines (might be debug output from the MCP server)\n        console.warn('Non-JSON output from MCP server:', line);\n      }\n    });\n  }\n\n  async send(\n    message: Readonly<AxMCPJSONRPCRequest<unknown>>\n  ): Promise<AxMCPJSONRPCResponse<unknown>> {\n    return new Promise<AxMCPJSONRPCResponse<unknown>>((resolve) => {\n      this.pendingResponses.set(message.id, (res: AxMCPJSONRPCResponse) => {\n        resolve(res as AxMCPJSONRPCResponse<unknown>);\n      });\n      this.process.stdin.write(`${JSON.stringify(message)}\\n`);\n    });\n  }\n\n  async sendNotification(\n    message: Readonly<AxMCPJSONRPCNotification>\n  ): Promise<void> {\n    this.process.stdin.write(`${JSON.stringify(message)}\\n`);\n  }\n\n  async connect(): Promise<void> {\n    // Connection is implicit when the process is spawned\n    return Promise.resolve();\n  }\n\n  /**\n   * Terminate the child process and clean up resources\n   */\n  async terminate(): Promise<void> {\n    this.rl.close();\n    this.process.kill();\n    return new Promise((resolve) => {\n      this.process.on('exit', () => resolve());\n    });\n  }\n}\n\n/**\n * Create a new AxMCPStdioTransport instance\n * @param config Configuration for the stdio transport\n * @returns A new AxMCPStdioTransport instance\n */\nexport function axCreateMCPStdioTransport(\n  config: Readonly<StdioTransportConfig>\n): AxMCPStdioTransport {\n  return new AxMCPStdioTransport(config);\n}\n","import * as _fs from 'node:fs';\nimport * as _http from 'node:http';\nimport * as _https from 'node:https';\nimport * as _os from 'node:os';\nimport * as _process from 'node:process';\nimport { runInNewContext } from 'node:vm';\nimport type { AxFunction } from '@ax-llm/ax';\n\n// Local implementation of getCrypto since it's not exported from main package\nfunction getCrypto() {\n  if (globalThis.crypto && typeof globalThis.crypto.randomUUID === 'function') {\n    return globalThis.crypto;\n  }\n  throw new Error(\n    'Web Crypto API with randomUUID support not available. Requires Node.js 16+ or modern browser.'\n  );\n}\n\nexport enum AxJSInterpreterPermission {\n  FS = 'node:fs',\n  NET = 'net',\n  OS = 'os',\n  CRYPTO = 'crypto',\n  PROCESS = 'process',\n}\n\ntype Context = {\n  console: Console;\n  fs: unknown;\n  http: unknown;\n  https: unknown;\n  os: unknown;\n  crypto: unknown;\n  process: unknown;\n};\n\nexport class AxJSInterpreter {\n  private permissions: readonly AxJSInterpreterPermission[];\n\n  constructor({\n    permissions = [],\n  }:\n    | Readonly<{ permissions?: readonly AxJSInterpreterPermission[] }>\n    | undefined = {}) {\n    this.permissions = permissions ?? [];\n  }\n\n  private codeInterpreterJavascript(code: string): unknown {\n    const context: Partial<Context> = { console };\n\n    if (this.permissions.includes(AxJSInterpreterPermission.FS)) {\n      context.fs = _fs;\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.NET)) {\n      context.http = _http;\n      context.https = _https;\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.OS)) {\n      context.os = _os;\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.CRYPTO)) {\n      context.crypto = getCrypto();\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.PROCESS)) {\n      context.process = _process;\n    }\n\n    return runInNewContext(`(function() { ${code} })()`, context);\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: 'javascriptInterpreter',\n      description:\n        'Use this function to run Javascript code and get any expected return value',\n      parameters: {\n        type: 'object',\n        properties: {\n          code: {\n            type: 'string',\n            description: 'JS code with a return value in the end.',\n          },\n        },\n        required: ['code'],\n      },\n\n      func: ({ code }: Readonly<{ code: string }>) =>\n        this.codeInterpreterJavascript(code),\n    };\n  }\n}\n\n// Factory function following the same pattern as MCP\nexport function axCreateJSInterpreter(\n  options?: Readonly<{ permissions?: readonly AxJSInterpreterPermission[] }>\n): AxJSInterpreter {\n  return new AxJSInterpreter(options);\n}\n"]}