{"version":3,"sources":["../mcp/stdioTransport.ts","../functions/jsInterpreter.ts"],"sourcesContent":["import { type ChildProcessWithoutNullStreams, spawn } from 'node:child_process';\nimport readline from 'node:readline';\n\nimport type {\n  AxMCPJSONRPCNotification,\n  AxMCPJSONRPCRequest,\n  AxMCPJSONRPCResponse,\n  AxMCPTransport,\n} from '@ax-llm/ax';\n\nexport interface StdioTransportConfig {\n  command: string;\n  args?: string[];\n  env?: NodeJS.ProcessEnv;\n}\n\nexport class AxMCPStdioTransport implements AxMCPTransport {\n  private process: ChildProcessWithoutNullStreams;\n  private rl: readline.Interface;\n  private pendingResponses = new Map<\n    string | number,\n    (res: AxMCPJSONRPCResponse) => void\n  >();\n\n  constructor(config: Readonly<StdioTransportConfig>) {\n    this.process = spawn(config.command, config.args ?? [], {\n      env: config.env ? { ...process.env, ...config.env } : process.env,\n    });\n    this.rl = readline.createInterface({ input: this.process.stdout });\n    this.rl.on('line', (line) => {\n      try {\n        const response: AxMCPJSONRPCResponse = JSON.parse(line);\n        const resolver = this.pendingResponses.get(response.id);\n        if (resolver) {\n          resolver(response);\n          this.pendingResponses.delete(response.id);\n        }\n      } catch (_error) {\n        // Skip non-JSON lines (might be debug output from the MCP server)\n        console.warn('Non-JSON output from MCP server:', line);\n      }\n    });\n  }\n\n  async send(\n    message: Readonly<AxMCPJSONRPCRequest<unknown>>\n  ): Promise<AxMCPJSONRPCResponse<unknown>> {\n    return new Promise<AxMCPJSONRPCResponse<unknown>>((resolve) => {\n      this.pendingResponses.set(message.id, (res: AxMCPJSONRPCResponse) => {\n        resolve(res as AxMCPJSONRPCResponse<unknown>);\n      });\n      this.process.stdin.write(`${JSON.stringify(message)}\\n`);\n    });\n  }\n\n  async sendNotification(\n    message: Readonly<AxMCPJSONRPCNotification>\n  ): Promise<void> {\n    this.process.stdin.write(`${JSON.stringify(message)}\\n`);\n  }\n\n  async connect(): Promise<void> {\n    // Connection is implicit when the process is spawned\n    return Promise.resolve();\n  }\n\n  /**\n   * Terminate the child process and clean up resources\n   */\n  async terminate(): Promise<void> {\n    this.rl.close();\n    this.process.kill();\n    return new Promise((resolve) => {\n      this.process.on('exit', () => resolve());\n    });\n  }\n}\n\n/**\n * Create a new AxMCPStdioTransport instance\n * @param config Configuration for the stdio transport\n * @returns A new AxMCPStdioTransport instance\n */\nexport function axCreateMCPStdioTransport(\n  config: Readonly<StdioTransportConfig>\n): AxMCPStdioTransport {\n  return new AxMCPStdioTransport(config);\n}\n","import * as _fs from 'node:fs';\nimport * as _http from 'node:http';\nimport * as _https from 'node:https';\nimport * as _os from 'node:os';\nimport * as _process from 'node:process';\nimport { runInNewContext } from 'node:vm';\nimport type { AxFunction } from '@ax-llm/ax';\n\n// Local implementation of getCrypto since it's not exported from main package\nfunction getCrypto() {\n  if (globalThis.crypto && typeof globalThis.crypto.randomUUID === 'function') {\n    return globalThis.crypto;\n  }\n  throw new Error(\n    'Web Crypto API with randomUUID support not available. Requires Node.js 16+ or modern browser.'\n  );\n}\n\nexport enum AxJSInterpreterPermission {\n  FS = 'node:fs',\n  NET = 'net',\n  OS = 'os',\n  CRYPTO = 'crypto',\n  PROCESS = 'process',\n}\n\ntype Context = {\n  console: Console;\n  fs: unknown;\n  http: unknown;\n  https: unknown;\n  os: unknown;\n  crypto: unknown;\n  process: unknown;\n};\n\nexport class AxJSInterpreter {\n  private permissions: readonly AxJSInterpreterPermission[];\n\n  constructor({\n    permissions = [],\n  }:\n    | Readonly<{ permissions?: readonly AxJSInterpreterPermission[] }>\n    | undefined = {}) {\n    this.permissions = permissions ?? [];\n  }\n\n  private codeInterpreterJavascript(code: string): unknown {\n    const context: Partial<Context> = { console };\n\n    if (this.permissions.includes(AxJSInterpreterPermission.FS)) {\n      context.fs = _fs;\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.NET)) {\n      context.http = _http;\n      context.https = _https;\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.OS)) {\n      context.os = _os;\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.CRYPTO)) {\n      context.crypto = getCrypto();\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.PROCESS)) {\n      context.process = _process;\n    }\n\n    return runInNewContext(`(function() { ${code} })()`, context);\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: 'javascriptInterpreter',\n      description:\n        'Use this function to run Javascript code and get any expected return value',\n      parameters: {\n        type: 'object',\n        properties: {\n          code: {\n            type: 'string',\n            description: 'JS code with a return value in the end.',\n          },\n        },\n        required: ['code'],\n      },\n\n      func: ({ code }: Readonly<{ code: string }>) =>\n        this.codeInterpreterJavascript(code),\n    };\n  }\n}\n\n// Factory function following the same pattern as MCP\nexport function axCreateJSInterpreter(\n  options?: Readonly<{ permissions?: readonly AxJSInterpreterPermission[] }>\n): AxJSInterpreter {\n  return new AxJSInterpreter(options);\n}\n"],"mappings":"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","names":["spawn","readline","AxMCPStdioTransport","config","line","response","resolver","message","resolve","res","axCreateMCPStdioTransport","_fs","_http","_https","_os","_process","runInNewContext","getCrypto","AxJSInterpreterPermission","AxJSInterpreter","permissions","code","context","axCreateJSInterpreter","options"]}