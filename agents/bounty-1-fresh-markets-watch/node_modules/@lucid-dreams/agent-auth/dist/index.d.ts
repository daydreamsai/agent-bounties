import { AgentChallengeRequest, AgentChallengeResponse, AgentExchangeRequest, AgentExchangeResponse, AgentRefreshRequest, postV1AuthAgentsByAgentRefChallenge, getV1Agents, AgentListResponse as AgentListResponse$1, AgentDetail as AgentDetail$1, PostV1AgentsByAgentRefWalletSignMessageData, AgentWalletSignedResponse as AgentWalletSignedResponse$1, PostV1AgentsByAgentRefWalletSignTypedDataData, PostV1AgentsByAgentRefWalletSignTransactionData, PostV1AgentsByAgentRefWalletSendTransactionData, AgentWalletTransactionResponse as AgentWalletTransactionResponse$1, postV1AuthAgentsByAgentRefExchange, postV1AuthAgentsByAgentRefRefresh, getV1AgentsByAgentRef, postV1AgentsByAgentRefWalletSignMessage, postV1AgentsByAgentRefWalletSignTypedData, postV1AgentsByAgentRefWalletSignTransaction, postV1AgentsByAgentRefWalletSendTransaction } from '@lucid-dreams/sdk';
export { AgentChallengeRequest, AgentChallengeResponse, AgentExchangeRequest, AgentExchangeResponse, AgentRefreshRequest } from '@lucid-dreams/sdk';

type HttpMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS";
type HttpResponseType = "json" | "text" | "arrayBuffer" | "blob" | "stream" | "response";
type QueryParameters = Record<string, string | number | boolean | null | undefined>;
type FetchPreconnect = typeof fetch extends {
    preconnect: infer T;
} ? T : (input: RequestInfo | URL, init?: RequestInit) => Promise<void>;
type FetchExecutor = ((input: RequestInfo | URL, init?: RequestInit) => Promise<Response>) & {
    /**
     * Bun extends the global fetch with a preconnect helper. The generated SDK expects it to exist,
     * so transport implementations must expose a compatible surface.
     */
    preconnect: FetchPreconnect;
};
interface HttpRequestOptions<TResponse = unknown> {
    /**
     * Destination URL. Relative paths require a transport configured with a base URL.
     */
    url: string | URL;
    method?: HttpMethod;
    headers?: HeadersInit;
    /**
     * Raw body to send with the request.
     */
    body?: BodyInit | null;
    /**
     * Structured payload that will be JSON-encoded automatically.
     */
    json?: unknown;
    /**
     * Query parameters appended to the resolved URL.
     */
    query?: QueryParameters;
    /**
     * Abort signal provided by the caller.
     */
    signal?: AbortSignal;
    /**
     * Override response parsing strategy. Defaults to `json`.
     */
    parseAs?: HttpResponseType;
    /**
     * Maximum time in milliseconds before the transport aborts the request.
     */
    timeoutMs?: number;
    /**
     * Prevent the transport from throwing on non-2xx responses.
     */
    throwOnError?: boolean;
}
interface HttpResponse<TData = unknown> {
    status: number;
    headers: Headers;
    data: TData;
    raw: Response;
    url: string;
}
interface HttpTransport {
    request<TResponse = unknown>(options: HttpRequestOptions<TResponse>): Promise<HttpResponse<TResponse>>;
    /**
     * Returns a fetch-compatible function that honours the transport configuration.
    */
    asFetch(): FetchExecutor;
}
type HttpTransportErrorCode = "ConfigurationError" | "NetworkError" | "TimeoutError" | "AbortError" | "HttpError" | "ParseError";
interface HttpTransportErrorOptions {
    code: HttpTransportErrorCode;
    url: string;
    status?: number;
    response?: Response;
    data?: unknown;
    cause?: unknown;
}
declare class HttpTransportError extends Error {
    readonly code: HttpTransportErrorCode;
    readonly url: string;
    readonly status?: number;
    readonly response?: Response;
    readonly data?: unknown;
    readonly cause?: unknown;
    constructor(message: string, options: HttpTransportErrorOptions);
}
declare const isHttpTransportError: (error: unknown) => error is HttpTransportError;

interface StorageAdapter<T = unknown> {
    get(key: string): Promise<T | null>;
    set(key: string, value: T): Promise<void>;
    delete(key: string): Promise<void>;
}
type StorageFactory<T = unknown> = () => StorageAdapter<T>;

interface TokenBundleInput {
    accessToken: string;
    accessTokenExpiresAt: Date | string;
    refreshToken: string;
    refreshTokenExpiresAt: Date | string;
    revocationNonce?: string | null;
    scopes?: string[] | null;
}
interface TokenSnapshot {
    accessToken: string;
    accessTokenExpiresAt: Date;
    refreshToken: string;
    refreshTokenExpiresAt: Date;
    revocationNonce?: string;
    scopes?: string[];
}
interface CachedAccessToken {
    token: string;
    expiresAt: Date;
    scopes?: string[];
    refreshToken: string;
    refreshTokenExpiresAt: Date;
    revocationNonce?: string;
}
interface TokenManagerOptions {
    storage?: StorageAdapter<string>;
    storageKey?: string;
    refreshLeadTimeMs?: number;
    now?: () => number;
}
interface CancelHandle {
    cancel(): void;
}
declare class TokenManager {
    private readonly storage;
    private readonly storageKey;
    private readonly refreshLeadTimeMs;
    private readonly now;
    private tokens;
    private refreshTimer;
    private refreshPromise;
    constructor(options?: TokenManagerOptions);
    hydrate(): Promise<TokenSnapshot | null>;
    getSnapshot(): TokenSnapshot | null;
    getCachedAccessToken(): CachedAccessToken | null;
    setTokens(bundle: TokenBundleInput): Promise<TokenSnapshot>;
    clear(): Promise<void>;
    scheduleRefresh(trigger: () => Promise<TokenBundleInput>): CancelHandle;
    withRefreshLock<T>(fn: () => Promise<T>): Promise<T>;
    private normalizeBundle;
    private clearScheduledRefresh;
}

declare class AgentAuthClient {
    private readonly client?;
    private readonly baseUrl?;
    private readonly fetchImpl?;
    private readonly defaultAgentRef?;
    private readonly defaultHeaders?;
    constructor(options: AgentAuthClientOptions);
    requestChallenge(payload: AgentChallengeRequest, options?: AgentAuthRequestOptions): Promise<AgentChallengeResponse>;
    exchange(payload: AgentExchangeRequest, options?: AgentAuthRequestOptions): Promise<AgentExchangeResponse>;
    refresh(payload: AgentRefreshRequest, options?: AgentAuthRequestOptions): Promise<AgentExchangeResponse>;
    private buildRequestConfig;
    private resolveAgentRef;
    private mergeHeaders;
    private wrapError;
    private makeRequestOptions;
    private unwrapResult;
}

type AgentListResponse = AgentListResponse$1;
type AgentDetail = AgentDetail$1;
type AgentWalletSignedResponse = AgentWalletSignedResponse$1;
type AgentWalletTransactionResponse = AgentWalletTransactionResponse$1;
type AgentWalletSignMessageRequest = PostV1AgentsByAgentRefWalletSignMessageData["body"];
type AgentWalletSignTypedDataRequest = PostV1AgentsByAgentRefWalletSignTypedDataData["body"];
type AgentWalletSignTransactionRequest = PostV1AgentsByAgentRefWalletSignTransactionData["body"];
type AgentWalletSendTransactionRequest = PostV1AgentsByAgentRefWalletSendTransactionData["body"];
type ChallengeOptions = Parameters<typeof postV1AuthAgentsByAgentRefChallenge>[0];
type ExchangeOptions = Parameters<typeof postV1AuthAgentsByAgentRefExchange>[0];
type RefreshOptions = Parameters<typeof postV1AuthAgentsByAgentRefRefresh>[0];
type AgentAuthSdkClient = NonNullable<ChallengeOptions["client"]>;
type AgentAuthSdkOptions = ChallengeOptions | ExchangeOptions | RefreshOptions;
type ListAgentsOptions = Parameters<typeof getV1Agents>[0];
type GetAgentOptions = Parameters<typeof getV1AgentsByAgentRef>[0];
type WalletSignMessageOptions = Parameters<typeof postV1AgentsByAgentRefWalletSignMessage>[0];
type WalletSignTypedDataOptions = Parameters<typeof postV1AgentsByAgentRefWalletSignTypedData>[0];
type WalletSignTransactionOptions = Parameters<typeof postV1AgentsByAgentRefWalletSignTransaction>[0];
type WalletSendTransactionOptions = Parameters<typeof postV1AgentsByAgentRefWalletSendTransaction>[0];
type AgentApiSdkClient = NonNullable<ListAgentsOptions["client"]>;
type AgentApiSdkOptions = ListAgentsOptions | GetAgentOptions | WalletSignMessageOptions | WalletSignTypedDataOptions | WalletSignTransactionOptions | WalletSendTransactionOptions;
interface AgentAuthClientOptions {
    /**
     * Default agent reference used in requests when one isn't provided explicitly.
     */
    agentRef?: string;
    /**
     * Base URL for the Lucid API. Required when a custom client isn't supplied.
     */
    baseUrl?: string;
    /**
     * Optional fetch implementation for environments that don't expose the global fetch.
     */
    fetch?: FetchExecutor;
    /**
     * Headers that should be sent with every request.
     */
    headers?: HeadersInit;
    /**
     * Custom SDK client instance. When provided, baseUrl/fetch are optional.
     */
    client?: AgentAuthSdkClient;
}
interface AgentAuthRequestOptions {
    /**
     * Override the agent ref for this request.
     */
    agentRef?: string;
    /**
     * Additional headers to send with the request.
     */
    headers?: HeadersInit;
    /**
     * Abort signal for cancelling in-flight requests.
     */
    signal?: AbortSignal;
    /**
     * Arbitrary metadata forwarded to the generated SDK meta bag.
     */
    meta?: Record<string, unknown>;
}
interface ChallengeSigner {
    signChallenge(challenge: AgentChallengeResponse["challenge"]): Promise<string>;
}
interface AgentRuntimeConfig {
    baseUrl: string;
    agentRef: string;
    credentialId: string;
    refreshToken?: string;
    scopes?: string[];
}
interface AgentRuntimeWallet {
    signer: ChallengeSigner;
}
interface AgentRuntimeOptions {
    config: AgentRuntimeConfig;
    wallet: AgentRuntimeWallet;
    transport: HttpTransport;
    authClient: AgentAuthClient;
    apiClient?: AgentApiClient;
    tokenManager: TokenManager;
    refreshLeadTimeMs: number;
    now: () => number;
}
type AgentRuntimeEvent = "authenticated" | "tokenRefreshed" | "refreshFailed" | "tokensCleared";
interface AuthenticatedEvent {
    accessToken: string;
    refreshToken: string;
    scopes?: string[];
    expiresAt: Date;
    refreshTokenExpiresAt: Date;
}
interface TokenRefreshedEvent extends AuthenticatedEvent {
}
interface RefreshFailedEvent {
    error: unknown;
}
interface TokensClearedEvent {
    reason?: string;
}
type AgentRuntimeEventPayloads = {
    authenticated: AuthenticatedEvent;
    tokenRefreshed: TokenRefreshedEvent;
    refreshFailed: RefreshFailedEvent;
    tokensCleared: TokensClearedEvent;
};
type AgentRuntimeEventHandler<TEvent extends AgentRuntimeEvent> = (payload: AgentRuntimeEventPayloads[TEvent]) => void;

interface AgentApiClientOptions {
    transport: HttpTransport;
    /**
     * Optional base URL forwarded to the generated SDK.
     */
    baseUrl?: string;
    /**
     * Default headers attached to every request.
     */
    headers?: HeadersInit;
    /**
     * Default agent reference applied when a method doesn't provide one.
     */
    agentRef?: string;
    /**
     * Optional custom SDK client instance.
     */
    client?: AgentApiSdkClient;
    /**
     * Callback that resolves the current access token.
     */
    getAccessToken: () => Promise<string | null | undefined>;
}
interface AgentRequestOptions {
    headers?: HeadersInit;
    signal?: AbortSignal;
    meta?: Record<string, unknown>;
}
interface AgentScopedRequestOptions extends AgentRequestOptions {
    agentRef?: string;
}
declare class AgentApiClient {
    private readonly client?;
    private readonly baseUrl?;
    private readonly defaultHeaders?;
    private readonly defaultAgentRef?;
    private readonly fetchImpl;
    private readonly getAccessToken;
    constructor(options: AgentApiClientOptions);
    listAgents(options?: AgentRequestOptions): Promise<AgentListResponse>;
    getAgent(options?: AgentScopedRequestOptions): Promise<AgentDetail>;
    signMessage(payload: AgentWalletSignMessageRequest, options?: AgentScopedRequestOptions): Promise<AgentWalletSignedResponse>;
    signTypedData(payload: AgentWalletSignTypedDataRequest, options?: AgentScopedRequestOptions): Promise<AgentWalletSignedResponse>;
    signTransaction(payload: AgentWalletSignTransactionRequest, options?: AgentScopedRequestOptions): Promise<AgentWalletSignedResponse>;
    sendTransaction(payload: AgentWalletSendTransactionRequest, options?: AgentScopedRequestOptions): Promise<AgentWalletTransactionResponse>;
    private makeBaseOptions;
    private buildHeaders;
    private resolveAgentRef;
    private unwrapResult;
}

declare const DEFAULT_CONFIG_FILENAME = ".lucid-agent.json";
declare const DEFAULT_API_BASE_URL = "https://api.lucid.run";
declare const ENV_BASE_URL = "LUCID_AGENT_BASE_URL";
declare const ENV_AGENT_REF = "LUCID_AGENT_AGENT_REF";
declare const ENV_AGENT_ID = "LUCID_AGENT_AGENT_ID";
declare const ENV_CREDENTIAL_ID = "LUCID_AGENT_CREDENTIAL_ID";
declare const ENV_REFRESH_TOKEN = "LUCID_AGENT_REFRESH_TOKEN";
declare const ENV_SCOPES = "LUCID_AGENT_SCOPES";
declare const ENV_CONFIG_PATH = "LUCID_AGENT_CONFIG_PATH";
interface AgentConfigFile {
    agentId?: string;
    agentRef?: string;
    credentialId?: string;
    refreshToken?: string;
    scopes?: string[] | null;
    apiBaseUrl?: string;
    [key: string]: unknown;
}
interface AgentConfigOverrides {
    baseUrl?: string;
    agentRef?: string;
    credentialId?: string;
    refreshToken?: string;
    scopes?: string[];
}
interface ConfigLoaderOptions {
    /**
     * Path to the config file. Defaults to `.lucid-agent.json` in the current working directory.
     */
    path?: string;
    /**
     * Working directory used when resolving relative config paths.
     */
    cwd?: string;
    /**
     * Environment variables used for overrides. Defaults to `process.env`.
     */
    env?: Record<string, string | undefined>;
    /**
     * Runtime overrides applied last.
     */
    overrides?: AgentConfigOverrides;
    /**
     * Custom file reader for testing.
     */
    readFile?: (path: string) => Promise<string>;
}
interface LoadedAgentRuntimeConfig {
    config: AgentRuntimeConfig;
    /**
     * Path the loader attempted to read. `undefined` when running env-only mode.
     */
    sourcePath?: string;
    /**
     * Raw parsed configuration file (if one existed).
     */
    fileConfig?: AgentConfigFile | null;
}
declare function loadAgentRuntimeConfig(options?: ConfigLoaderOptions): Promise<LoadedAgentRuntimeConfig>;

interface AgentRuntimeFromConfigOptions {
    config: AgentRuntimeConfig;
    wallet: AgentRuntimeWallet;
    fetch?: FetchExecutor;
    transport?: HttpTransport;
    authClient?: AgentAuthClient;
    apiClient?: AgentApiClient;
    tokenManager?: TokenManager;
    storage?: StorageAdapter<string>;
    headers?: HeadersInit;
    refreshLeadTimeMs?: number;
    now?: () => number;
}
interface AgentRuntimeLoadOptions extends Omit<AgentRuntimeFromConfigOptions, "config"> {
    loader?: ConfigLoaderOptions;
}
interface AgentRuntimeLoadResult extends LoadedAgentRuntimeConfig {
    runtime: AgentRuntime;
}
interface AuthenticatedSession {
    accessToken: string;
    refreshToken: string;
    expiresAt: Date;
    refreshTokenExpiresAt: Date;
    scopes?: string[];
}
declare class AgentRuntime {
    static fromConfig(options: AgentRuntimeFromConfigOptions): Promise<AgentRuntime>;
    static load(options: AgentRuntimeLoadOptions): Promise<AgentRuntimeLoadResult>;
    readonly api: AgentApiClient;
    private readonly config;
    private readonly wallet;
    private readonly transport;
    private readonly authClient;
    private readonly tokenManager;
    private readonly refreshLeadTimeMs;
    private readonly now;
    private readonly handlers;
    private refreshTimer;
    private constructor();
    authenticate(): Promise<AuthenticatedSession>;
    ensureAccessToken(): Promise<string>;
    shutdown(): Promise<void>;
    on<TEvent extends AgentRuntimeEvent>(event: TEvent, handler: AgentRuntimeEventHandler<TEvent>): () => void;
    clearTokens(reason?: string): Promise<void>;
    private initialize;
    private refreshTokens;
    private storeTokens;
    private scheduleRefresh;
    private clearRefreshTimer;
    private emit;
    private snapshotToSession;
}

type AgentAuthClientErrorCode = "AgentRefRequired" | "BaseUrlRequired" | "EmptyResponse" | "RequestFailed";
interface AgentAuthClientErrorContext {
    agentRef?: string;
    cause?: unknown;
}
declare class AgentAuthClientError extends Error {
    readonly code: AgentAuthClientErrorCode;
    readonly agentRef?: string;
    readonly cause?: unknown;
    constructor(code: AgentAuthClientErrorCode, message: string, context?: AgentAuthClientErrorContext);
}
type TokenManagerErrorCode = "TokensUnavailable" | "StorageFailure";
interface TokenManagerErrorContext {
    cause?: unknown;
}
declare class TokenManagerError extends Error {
    readonly code: TokenManagerErrorCode;
    readonly cause?: unknown;
    constructor(code: TokenManagerErrorCode, message: string, context?: TokenManagerErrorContext);
}
type AgentApiClientErrorCode = "AccessTokenRequired" | "AgentRefRequired" | "EmptyResponse" | "RequestFailed";
interface AgentApiClientErrorContext {
    agentRef?: string;
    status?: number;
    details?: unknown;
    cause?: unknown;
}
declare class AgentApiClientError extends Error {
    readonly code: AgentApiClientErrorCode;
    readonly agentRef?: string;
    readonly status?: number;
    readonly details?: unknown;
    readonly cause?: unknown;
    constructor(code: AgentApiClientErrorCode, message: string, context?: AgentApiClientErrorContext);
}
type AgentRuntimeErrorCode = "ConfigurationError" | "AuthenticationFailed" | "RefreshFailed" | "TokensUnavailable";
interface AgentRuntimeErrorContext {
    cause?: unknown;
}
declare class AgentRuntimeError extends Error {
    readonly code: AgentRuntimeErrorCode;
    readonly cause?: unknown;
    constructor(code: AgentRuntimeErrorCode, message: string, context?: AgentRuntimeErrorContext);
}

declare class MemoryStorageAdapter<T = unknown> implements StorageAdapter<T> {
    private readonly store;
    get(key: string): Promise<T | null>;
    set(key: string, value: T): Promise<void>;
    delete(key: string): Promise<void>;
}
declare const createMemoryStorageAdapter: <T = unknown>() => MemoryStorageAdapter<T>;

interface FetchTransportOptions {
    baseUrl?: string;
    defaultHeaders?: HeadersInit;
    defaultTimeoutMs?: number;
    fetch?: FetchExecutor;
}
declare const createFetchTransport: (options?: FetchTransportOptions) => HttpTransport;

interface UndiciTransportOptions extends FetchTransportOptions {
    /**
     * Optional Undici dispatcher instance injected into each request.
     */
    dispatcher?: unknown;
}
declare const createUndiciTransport: (options?: UndiciTransportOptions) => HttpTransport;

interface WalletMetadata {
    id?: string | null;
    address?: string | null;
    chain?: string | null;
    chainType?: string | null;
    provider?: string | null;
    accountId?: string | null;
    label?: string | null;
    caip2?: string | null;
}
interface NormalizedChallenge {
    id: string;
    credentialId: string | null;
    payload: unknown;
    payloadHash: string;
    nonce: string;
    scopes: string[];
    issuedAt: Date;
    expiresAt: Date;
    serverSignature: string | null;
    message: string | null;
}
interface WalletConnector extends ChallengeSigner {
    /**
     * Optional hook for retrieving wallet metadata that was discovered during
     * prior signing operations.
     */
    getWalletMetadata(): Promise<WalletMetadata | null>;
    /**
     * Optional helper that can be used by runtimes to assert chain support
     * before delegating signing to the connector.
     */
    supportsCaip2?(caip2: string): boolean | Promise<boolean>;
    /**
     * Optional helper returning the primary signing address (if known).
     */
    getAddress?(): Promise<string | null>;
}
interface ChallengeNormalizationOptions {
    /**
     * When true, objects are stringified using a stable key order.
     * Defaults to true.
     */
    stableStringify?: boolean;
}
declare const normalizeChallenge: (challenge: AgentChallengeResponse["challenge"], options?: ChallengeNormalizationOptions) => NormalizedChallenge;
declare const stableJsonStringify: (value: unknown) => string;
declare const extractSignature: (payload: unknown) => string | null;
declare const extractWalletMetadata: (payload: unknown) => WalletMetadata | null;
type ChallengeMessageEncoding = "utf-8" | "hex";
declare const detectMessageEncoding: (message: string) => ChallengeMessageEncoding;

interface ServerOrchestratorWalletConnectorOptions {
    baseUrl: string;
    agentRef: string;
    fetch?: FetchExecutor;
    headers?: HeadersInit;
    accessToken?: string | null;
    authorizationContext?: Record<string, unknown>;
}
declare class ServerOrchestratorMissingAccessTokenError extends Error {
    constructor();
}
declare class ServerOrchestratorWalletConnector implements WalletConnector {
    private readonly baseUrl;
    private readonly agentRef;
    private readonly fetchImpl;
    private readonly defaultHeaders;
    private readonly authorizationContext;
    private accessToken;
    private cachedMetadata;
    constructor(options: ServerOrchestratorWalletConnectorOptions);
    setAccessToken(token: string | null): void;
    signChallenge(challenge: AgentChallengeResponse["challenge"]): Promise<string>;
    getWalletMetadata(): Promise<WalletMetadata | null>;
    supportsCaip2(_: string): boolean;
    getAddress(): Promise<string | null>;
    private buildHeaders;
}

interface CreateWalletConfig {
    /**
     * Override the Lucid API base URL. Defaults to https://lucid.daydream.systems.
     */
    baseUrl?: string;
    /** Optional override for the agent reference. Falls back to `LUCID_AGENT_REF`. */
    agentRef?: string;
    /** Optional override for the agent credential ID. Falls back to `LUCID_AGENT_CREDENTIAL`. */
    credentialId?: string;
    /** Optional override for the refresh token. Falls back to `LUCID_AGENT_REFRESH_TOKEN`. */
    refreshToken?: string;
    /** Optional override for requested scopes. Falls back to parsing `LUCID_AGENT_SCOPES`. */
    scopes?: string[];
}
interface CreateWalletOptions {
    /**
     * Optional runtime configuration overrides. Defaults are sourced from environment variables.
     */
    config?: CreateWalletConfig;
    /**
     * Optional overrides for wallet connector wiring.
     */
    wallet?: {
        /**
         * Provide a fully configured connector. When omitted, a server orchestrator connector is created.
         */
        connector?: WalletConnector;
        /**
         * Options used when bootstrapping the default server orchestrator connector.
         */
        server?: CreateWalletServerOptions;
    };
    /**
     * Inject a custom fetch implementation. Required in environments without global fetch.
     */
    fetch?: FetchExecutor;
    /**
     * Override the HTTP transport shared with the generated SDK.
     */
    transport?: HttpTransport;
    /**
     * Provide a custom storage adapter for token persistence.
     */
    storage?: StorageAdapter<string>;
    /**
     * Default headers appended to every network request.
     */
    headers?: HeadersInit;
    /**
     * Pre-register event handlers on the underlying runtime.
     */
    events?: {
        [Event in AgentRuntimeEvent]?: AgentRuntimeEventHandler<Event> | Array<AgentRuntimeEventHandler<Event>>;
    };
}
interface WalletClient {
    /** Underlying runtime instance for advanced scenarios. */
    readonly runtime: AgentRuntime;
    /** Wallet connector handling challenge signing. */
    readonly connector: WalletConnector;
    /** Ensure the agent is authenticated, returning the active session. */
    authenticate(): Promise<AuthenticatedSession>;
    /** Return a valid access token, refreshing or exchanging as needed. */
    ensureAccessToken(): Promise<string>;
    /** Sign an arbitrary message using the agent wallet. */
    signMessage(payload: AgentWalletSignMessageRequest): Promise<AgentWalletSignedResponse>;
    /** Sign typed data (EIP-712) using the agent wallet. */
    signTypedData(payload: AgentWalletSignTypedDataRequest): Promise<AgentWalletSignedResponse>;
    /** Sign a transaction payload without broadcasting it. */
    signTransaction(payload: AgentWalletSignTransactionRequest): Promise<AgentWalletSignedResponse>;
    /** Send a transaction via the agent wallet. */
    sendTransaction(payload: AgentWalletSendTransactionRequest): Promise<AgentWalletTransactionResponse>;
    /** Retrieve cached wallet metadata, if exposed by the connector. */
    getWalletMetadata(): Promise<WalletMetadata | null>;
    /** Resolve the primary signing address when exposed by the connector. */
    getAddress(): Promise<string | null>;
    /**
     * Subscribe to runtime events. Returns an unsubscribe handle mirroring `AgentRuntime.on`.
     */
    on<Event extends AgentRuntimeEvent>(event: Event, handler: AgentRuntimeEventHandler<Event>): () => void;
    /** Shut down the runtime, cancelling background refresh operations. */
    shutdown(): Promise<void>;
}
declare const createWallet: (options: CreateWalletOptions) => Promise<WalletClient>;
type CreateWalletServerOptions = Omit<ServerOrchestratorWalletConnectorOptions, "agentRef" | "fetch"> & {
    /**
     * Override the orchestrator base URL. Defaults to the runtime base URL.
     */
    baseUrl?: string;
    /**
     * Optional initial access token applied before authentication completes.
     */
    accessToken?: string | null;
};

type TypedDataPayload = {
    domain: Record<string, unknown>;
    primary_type: string;
    types: Record<string, Array<{
        name: string;
        type: string;
    }>>;
    message: Record<string, unknown>;
};
interface LocalEoaSigner {
    signMessage(message: string | Uint8Array): Promise<string>;
    signTypedData?(payload: TypedDataPayload): Promise<string>;
    getAddress?(): Promise<string | null>;
}
interface LocalEoaWalletConnectorOptions {
    signer: LocalEoaSigner;
    /** Optional static address hint to avoid additional signer roundtrips. */
    address?: string | null;
    /** Optional CAIP-2 identifier for the connected chain. */
    caip2?: string | null;
    chain?: string | null;
    chainType?: string | null;
    provider?: string | null;
    label?: string | null;
}
declare class LocalEoaWalletConnector implements WalletConnector {
    private readonly signer;
    private metadata;
    constructor(options: LocalEoaWalletConnectorOptions);
    signChallenge(challenge: AgentChallengeResponse["challenge"]): Promise<string>;
    getWalletMetadata(): Promise<WalletMetadata | null>;
    getAddress(): Promise<string | null>;
    supportsCaip2(caip2: string): boolean;
    private refreshMetadataFromSigner;
}

export { AgentApiClient, AgentApiClientError, type AgentApiClientErrorCode, type AgentApiClientErrorContext, type AgentApiClientOptions, type AgentApiSdkClient, type AgentApiSdkOptions, AgentAuthClient, AgentAuthClientError, type AgentAuthClientErrorCode, type AgentAuthClientErrorContext, type AgentAuthClientOptions, type AgentAuthRequestOptions, type AgentAuthSdkClient, type AgentAuthSdkOptions, type AgentConfigFile, type AgentConfigOverrides, type AgentDetail, type AgentListResponse, type AgentRequestOptions, AgentRuntime, type AgentRuntimeConfig, AgentRuntimeError, type AgentRuntimeErrorCode, type AgentRuntimeErrorContext, type AgentRuntimeEvent, type AgentRuntimeEventHandler, type AgentRuntimeEventPayloads, type AgentRuntimeFromConfigOptions, type AgentRuntimeLoadOptions, type AgentRuntimeLoadResult, type AgentRuntimeOptions, type AgentRuntimeWallet, type AgentScopedRequestOptions, type AgentWalletSendTransactionRequest, type AgentWalletSignMessageRequest, type AgentWalletSignTransactionRequest, type AgentWalletSignTypedDataRequest, type AgentWalletSignedResponse, type AgentWalletTransactionResponse, type AuthenticatedEvent, type AuthenticatedSession, type CachedAccessToken, type CancelHandle, type ChallengeMessageEncoding, type ChallengeNormalizationOptions, type ChallengeSigner, type ConfigLoaderOptions, type CreateWalletConfig, type CreateWalletOptions, DEFAULT_API_BASE_URL, DEFAULT_CONFIG_FILENAME, ENV_AGENT_ID, ENV_AGENT_REF, ENV_BASE_URL, ENV_CONFIG_PATH, ENV_CREDENTIAL_ID, ENV_REFRESH_TOKEN, ENV_SCOPES, type FetchExecutor, type FetchTransportOptions, type HttpMethod, type HttpRequestOptions, type HttpResponse, type HttpResponseType, type HttpTransport, HttpTransportError, type HttpTransportErrorCode, type HttpTransportErrorOptions, type LoadedAgentRuntimeConfig, type LocalEoaSigner, LocalEoaWalletConnector, type LocalEoaWalletConnectorOptions, MemoryStorageAdapter, type NormalizedChallenge, type QueryParameters, type RefreshFailedEvent, ServerOrchestratorMissingAccessTokenError, ServerOrchestratorWalletConnector, type ServerOrchestratorWalletConnectorOptions, type StorageAdapter, type StorageFactory, type TokenBundleInput, TokenManager, TokenManagerError, type TokenManagerErrorCode, type TokenManagerErrorContext, type TokenManagerOptions, type TokenRefreshedEvent, type TokenSnapshot, type TokensClearedEvent, type UndiciTransportOptions, type WalletClient, type WalletConnector, type WalletMetadata, createFetchTransport, createMemoryStorageAdapter, createUndiciTransport, createWallet, detectMessageEncoding, extractSignature, extractWalletMetadata, isHttpTransportError, loadAgentRuntimeConfig, normalizeChallenge, stableJsonStringify };
