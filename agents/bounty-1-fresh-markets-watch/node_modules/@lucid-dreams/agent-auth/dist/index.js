import '@tanstack/react-query';
import { readFile } from 'fs/promises';
import { isAbsolute, resolve } from 'path';

// ../sdk/src/core/bodySerializer.gen.ts
var jsonBodySerializer = {
  bodySerializer: (body) => JSON.stringify(
    body,
    (_key, value) => typeof value === "bigint" ? value.toString() : value
  )
};

// ../sdk/src/core/serverSentEvents.gen.ts
var createSseClient = ({
  onRequest,
  onSseError,
  onSseEvent,
  responseTransformer,
  responseValidator,
  sseDefaultRetryDelay,
  sseMaxRetryAttempts,
  sseMaxRetryDelay,
  sseSleepFn,
  url,
  ...options
}) => {
  let lastEventId;
  const sleep = sseSleepFn ?? ((ms) => new Promise((resolve2) => setTimeout(resolve2, ms)));
  const createStream = async function* () {
    let retryDelay = sseDefaultRetryDelay ?? 3e3;
    let attempt = 0;
    const signal = options.signal ?? new AbortController().signal;
    while (true) {
      if (signal.aborted) break;
      attempt++;
      const headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
      if (lastEventId !== void 0) {
        headers.set("Last-Event-ID", lastEventId);
      }
      try {
        const requestInit = {
          redirect: "follow",
          ...options,
          body: options.serializedBody,
          headers,
          signal
        };
        let request = new Request(url, requestInit);
        if (onRequest) {
          request = await onRequest(url, requestInit);
        }
        const _fetch = options.fetch ?? globalThis.fetch;
        const response = await _fetch(request);
        if (!response.ok)
          throw new Error(
            `SSE failed: ${response.status} ${response.statusText}`
          );
        if (!response.body) throw new Error("No body in SSE response");
        const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
        let buffer = "";
        const abortHandler = () => {
          try {
            reader.cancel();
          } catch {
          }
        };
        signal.addEventListener("abort", abortHandler);
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += value;
            const chunks = buffer.split("\n\n");
            buffer = chunks.pop() ?? "";
            for (const chunk of chunks) {
              const lines = chunk.split("\n");
              const dataLines = [];
              let eventName;
              for (const line of lines) {
                if (line.startsWith("data:")) {
                  dataLines.push(line.replace(/^data:\s*/, ""));
                } else if (line.startsWith("event:")) {
                  eventName = line.replace(/^event:\s*/, "");
                } else if (line.startsWith("id:")) {
                  lastEventId = line.replace(/^id:\s*/, "");
                } else if (line.startsWith("retry:")) {
                  const parsed = Number.parseInt(
                    line.replace(/^retry:\s*/, ""),
                    10
                  );
                  if (!Number.isNaN(parsed)) {
                    retryDelay = parsed;
                  }
                }
              }
              let data;
              let parsedJson = false;
              if (dataLines.length) {
                const rawData = dataLines.join("\n");
                try {
                  data = JSON.parse(rawData);
                  parsedJson = true;
                } catch {
                  data = rawData;
                }
              }
              if (parsedJson) {
                if (responseValidator) {
                  await responseValidator(data);
                }
                if (responseTransformer) {
                  data = await responseTransformer(data);
                }
              }
              onSseEvent?.({
                data,
                event: eventName,
                id: lastEventId,
                retry: retryDelay
              });
              if (dataLines.length) {
                yield data;
              }
            }
          }
        } finally {
          signal.removeEventListener("abort", abortHandler);
          reader.releaseLock();
        }
        break;
      } catch (error) {
        onSseError?.(error);
        if (sseMaxRetryAttempts !== void 0 && attempt >= sseMaxRetryAttempts) {
          break;
        }
        const backoff = Math.min(
          retryDelay * 2 ** (attempt - 1),
          sseMaxRetryDelay ?? 3e4
        );
        await sleep(backoff);
      }
    }
  };
  const stream = createStream();
  return { stream };
};

// ../sdk/src/core/pathSerializer.gen.ts
var separatorArrayExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var separatorArrayNoExplode = (style) => {
  switch (style) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
};
var separatorObjectExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var serializeArrayParam = ({
  allowReserved,
  explode,
  name,
  style,
  value
}) => {
  if (!explode) {
    const joinedValues2 = (allowReserved ? value : value.map((v) => encodeURIComponent(v))).join(separatorArrayNoExplode(style));
    switch (style) {
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      case "simple":
        return joinedValues2;
      default:
        return `${name}=${joinedValues2}`;
    }
  }
  const separator = separatorArrayExplode(style);
  const joinedValues = value.map((v) => {
    if (style === "label" || style === "simple") {
      return allowReserved ? v : encodeURIComponent(v);
    }
    return serializePrimitiveParam({
      allowReserved,
      name,
      value: v
    });
  }).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};
var serializePrimitiveParam = ({
  allowReserved,
  name,
  value
}) => {
  if (value === void 0 || value === null) {
    return "";
  }
  if (typeof value === "object") {
    throw new Error(
      "Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these."
    );
  }
  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;
};
var serializeObjectParam = ({
  allowReserved,
  explode,
  name,
  style,
  value,
  valueOnly
}) => {
  if (value instanceof Date) {
    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;
  }
  if (style !== "deepObject" && !explode) {
    let values = [];
    Object.entries(value).forEach(([key, v]) => {
      values = [
        ...values,
        key,
        allowReserved ? v : encodeURIComponent(v)
      ];
    });
    const joinedValues2 = values.join(",");
    switch (style) {
      case "form":
        return `${name}=${joinedValues2}`;
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      default:
        return joinedValues2;
    }
  }
  const separator = separatorObjectExplode(style);
  const joinedValues = Object.entries(value).map(
    ([key, v]) => serializePrimitiveParam({
      allowReserved,
      name: style === "deepObject" ? `${name}[${key}]` : key,
      value: v
    })
  ).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};

// ../sdk/src/core/utils.gen.ts
var PATH_PARAM_RE = /\{[^{}]+\}/g;
var defaultPathSerializer = ({ path, url: _url }) => {
  let url = _url;
  const matches = _url.match(PATH_PARAM_RE);
  if (matches) {
    for (const match of matches) {
      let explode = false;
      let name = match.substring(1, match.length - 1);
      let style = "simple";
      if (name.endsWith("*")) {
        explode = true;
        name = name.substring(0, name.length - 1);
      }
      if (name.startsWith(".")) {
        name = name.substring(1);
        style = "label";
      } else if (name.startsWith(";")) {
        name = name.substring(1);
        style = "matrix";
      }
      const value = path[name];
      if (value === void 0 || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        url = url.replace(
          match,
          serializeArrayParam({ explode, name, style, value })
        );
        continue;
      }
      if (typeof value === "object") {
        url = url.replace(
          match,
          serializeObjectParam({
            explode,
            name,
            style,
            value,
            valueOnly: true
          })
        );
        continue;
      }
      if (style === "matrix") {
        url = url.replace(
          match,
          `;${serializePrimitiveParam({
            name,
            value
          })}`
        );
        continue;
      }
      const replaceValue = encodeURIComponent(
        style === "label" ? `.${value}` : value
      );
      url = url.replace(match, replaceValue);
    }
  }
  return url;
};
var getUrl = ({
  baseUrl,
  path,
  query,
  querySerializer,
  url: _url
}) => {
  const pathUrl = _url.startsWith("/") ? _url : `/${_url}`;
  let url = (baseUrl ?? "") + pathUrl;
  if (path) {
    url = defaultPathSerializer({ path, url });
  }
  let search = query ? querySerializer(query) : "";
  if (search.startsWith("?")) {
    search = search.substring(1);
  }
  if (search) {
    url += `?${search}`;
  }
  return url;
};
function getValidRequestBody(options) {
  const hasBody = options.body !== void 0;
  const isSerializedBody = hasBody && options.bodySerializer;
  if (isSerializedBody) {
    if ("serializedBody" in options) {
      const hasSerializedBody = options.serializedBody !== void 0 && options.serializedBody !== "";
      return hasSerializedBody ? options.serializedBody : null;
    }
    return options.body !== "" ? options.body : null;
  }
  if (hasBody) {
    return options.body;
  }
  return void 0;
}

// ../sdk/src/core/auth.gen.ts
var getAuthToken = async (auth, callback) => {
  const token = typeof callback === "function" ? await callback(auth) : callback;
  if (!token) {
    return;
  }
  if (auth.scheme === "bearer") {
    return `Bearer ${token}`;
  }
  if (auth.scheme === "basic") {
    return `Basic ${btoa(token)}`;
  }
  return token;
};

// ../sdk/src/client/utils.gen.ts
var createQuerySerializer = ({
  parameters = {},
  ...args
} = {}) => {
  const querySerializer = (queryParams) => {
    const search = [];
    if (queryParams && typeof queryParams === "object") {
      for (const name in queryParams) {
        const value = queryParams[name];
        if (value === void 0 || value === null) {
          continue;
        }
        const options = parameters[name] || args;
        if (Array.isArray(value)) {
          const serializedArray = serializeArrayParam({
            allowReserved: options.allowReserved,
            explode: true,
            name,
            style: "form",
            value,
            ...options.array
          });
          if (serializedArray) search.push(serializedArray);
        } else if (typeof value === "object") {
          const serializedObject = serializeObjectParam({
            allowReserved: options.allowReserved,
            explode: true,
            name,
            style: "deepObject",
            value,
            ...options.object
          });
          if (serializedObject) search.push(serializedObject);
        } else {
          const serializedPrimitive = serializePrimitiveParam({
            allowReserved: options.allowReserved,
            name,
            value
          });
          if (serializedPrimitive) search.push(serializedPrimitive);
        }
      }
    }
    return search.join("&");
  };
  return querySerializer;
};
var getParseAs = (contentType) => {
  if (!contentType) {
    return "stream";
  }
  const cleanContent = contentType.split(";")[0]?.trim();
  if (!cleanContent) {
    return;
  }
  if (cleanContent.startsWith("application/json") || cleanContent.endsWith("+json")) {
    return "json";
  }
  if (cleanContent === "multipart/form-data") {
    return "formData";
  }
  if (["application/", "audio/", "image/", "video/"].some(
    (type) => cleanContent.startsWith(type)
  )) {
    return "blob";
  }
  if (cleanContent.startsWith("text/")) {
    return "text";
  }
  return;
};
var checkForExistence = (options, name) => {
  if (!name) {
    return false;
  }
  if (options.headers.has(name) || options.query?.[name] || options.headers.get("Cookie")?.includes(`${name}=`)) {
    return true;
  }
  return false;
};
var setAuthParams = async ({
  security,
  ...options
}) => {
  for (const auth of security) {
    if (checkForExistence(options, auth.name)) {
      continue;
    }
    const token = await getAuthToken(auth, options.auth);
    if (!token) {
      continue;
    }
    const name = auth.name ?? "Authorization";
    switch (auth.in) {
      case "query":
        if (!options.query) {
          options.query = {};
        }
        options.query[name] = token;
        break;
      case "cookie":
        options.headers.append("Cookie", `${name}=${token}`);
        break;
      case "header":
      default:
        options.headers.set(name, token);
        break;
    }
  }
};
var buildUrl = (options) => getUrl({
  baseUrl: options.baseUrl,
  path: options.path,
  query: options.query,
  querySerializer: typeof options.querySerializer === "function" ? options.querySerializer : createQuerySerializer(options.querySerializer),
  url: options.url
});
var mergeConfigs = (a, b) => {
  const config = { ...a, ...b };
  if (config.baseUrl?.endsWith("/")) {
    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);
  }
  config.headers = mergeHeaders(a.headers, b.headers);
  return config;
};
var headersEntries = (headers) => {
  const entries = [];
  headers.forEach((value, key) => {
    entries.push([key, value]);
  });
  return entries;
};
var mergeHeaders = (...headers) => {
  const mergedHeaders = new Headers();
  for (const header of headers) {
    if (!header) {
      continue;
    }
    const iterator = header instanceof Headers ? headersEntries(header) : Object.entries(header);
    for (const [key, value] of iterator) {
      if (value === null) {
        mergedHeaders.delete(key);
      } else if (Array.isArray(value)) {
        for (const v of value) {
          mergedHeaders.append(key, v);
        }
      } else if (value !== void 0) {
        mergedHeaders.set(
          key,
          typeof value === "object" ? JSON.stringify(value) : value
        );
      }
    }
  }
  return mergedHeaders;
};
var Interceptors = class {
  constructor() {
    this.fns = [];
  }
  clear() {
    this.fns = [];
  }
  eject(id) {
    const index = this.getInterceptorIndex(id);
    if (this.fns[index]) {
      this.fns[index] = null;
    }
  }
  exists(id) {
    const index = this.getInterceptorIndex(id);
    return Boolean(this.fns[index]);
  }
  getInterceptorIndex(id) {
    if (typeof id === "number") {
      return this.fns[id] ? id : -1;
    }
    return this.fns.indexOf(id);
  }
  update(id, fn) {
    const index = this.getInterceptorIndex(id);
    if (this.fns[index]) {
      this.fns[index] = fn;
      return id;
    }
    return false;
  }
  use(fn) {
    this.fns.push(fn);
    return this.fns.length - 1;
  }
};
var createInterceptors = () => ({
  error: new Interceptors(),
  request: new Interceptors(),
  response: new Interceptors()
});
var defaultQuerySerializer = createQuerySerializer({
  allowReserved: false,
  array: {
    explode: true,
    style: "form"
  },
  object: {
    explode: true,
    style: "deepObject"
  }
});
var defaultHeaders = {
  "Content-Type": "application/json"
};
var createConfig = (override = {}) => ({
  ...jsonBodySerializer,
  headers: defaultHeaders,
  parseAs: "auto",
  querySerializer: defaultQuerySerializer,
  ...override
});

// ../sdk/src/client/client.gen.ts
var createClient = (config = {}) => {
  let _config = mergeConfigs(createConfig(), config);
  const getConfig = () => ({ ..._config });
  const setConfig = (config2) => {
    _config = mergeConfigs(_config, config2);
    return getConfig();
  };
  const interceptors = createInterceptors();
  const beforeRequest = async (options) => {
    const opts = {
      ..._config,
      ...options,
      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,
      headers: mergeHeaders(_config.headers, options.headers),
      serializedBody: void 0
    };
    if (opts.security) {
      await setAuthParams({
        ...opts,
        security: opts.security
      });
    }
    if (opts.requestValidator) {
      await opts.requestValidator(opts);
    }
    if (opts.body !== void 0 && opts.bodySerializer) {
      opts.serializedBody = opts.bodySerializer(opts.body);
    }
    if (opts.body === void 0 || opts.serializedBody === "") {
      opts.headers.delete("Content-Type");
    }
    const url = buildUrl(opts);
    return { opts, url };
  };
  const request = async (options) => {
    const { opts, url } = await beforeRequest(options);
    const requestInit = {
      redirect: "follow",
      ...opts,
      body: getValidRequestBody(opts)
    };
    let request2 = new Request(url, requestInit);
    for (const fn of interceptors.request.fns) {
      if (fn) {
        request2 = await fn(request2, opts);
      }
    }
    const _fetch = opts.fetch;
    let response = await _fetch(request2);
    for (const fn of interceptors.response.fns) {
      if (fn) {
        response = await fn(response, request2, opts);
      }
    }
    const result = {
      request: request2,
      response
    };
    if (response.ok) {
      const parseAs = (opts.parseAs === "auto" ? getParseAs(response.headers.get("Content-Type")) : opts.parseAs) ?? "json";
      if (response.status === 204 || response.headers.get("Content-Length") === "0") {
        let emptyData;
        switch (parseAs) {
          case "arrayBuffer":
          case "blob":
          case "text":
            emptyData = await response[parseAs]();
            break;
          case "formData":
            emptyData = new FormData();
            break;
          case "stream":
            emptyData = response.body;
            break;
          case "json":
          default:
            emptyData = {};
            break;
        }
        return opts.responseStyle === "data" ? emptyData : {
          data: emptyData,
          ...result
        };
      }
      let data;
      switch (parseAs) {
        case "arrayBuffer":
        case "blob":
        case "formData":
        case "json":
        case "text":
          data = await response[parseAs]();
          break;
        case "stream":
          return opts.responseStyle === "data" ? response.body : {
            data: response.body,
            ...result
          };
      }
      if (parseAs === "json") {
        if (opts.responseValidator) {
          await opts.responseValidator(data);
        }
        if (opts.responseTransformer) {
          data = await opts.responseTransformer(data);
        }
      }
      return opts.responseStyle === "data" ? data : {
        data,
        ...result
      };
    }
    const textError = await response.text();
    let jsonError;
    try {
      jsonError = JSON.parse(textError);
    } catch {
    }
    const error = jsonError ?? textError;
    let finalError = error;
    for (const fn of interceptors.error.fns) {
      if (fn) {
        finalError = await fn(error, response, request2, opts);
      }
    }
    finalError = finalError || {};
    if (opts.throwOnError) {
      throw finalError;
    }
    return opts.responseStyle === "data" ? void 0 : {
      error: finalError,
      ...result
    };
  };
  const makeMethodFn = (method) => (options) => request({ ...options, method });
  const makeSseFn = (method) => async (options) => {
    const { opts, url } = await beforeRequest(options);
    return createSseClient({
      ...opts,
      body: opts.body,
      headers: opts.headers,
      method,
      onRequest: async (url2, init) => {
        let request2 = new Request(url2, init);
        for (const fn of interceptors.request.fns) {
          if (fn) {
            request2 = await fn(request2, opts);
          }
        }
        return request2;
      },
      url
    });
  };
  return {
    buildUrl,
    connect: makeMethodFn("CONNECT"),
    delete: makeMethodFn("DELETE"),
    get: makeMethodFn("GET"),
    getConfig,
    head: makeMethodFn("HEAD"),
    interceptors,
    options: makeMethodFn("OPTIONS"),
    patch: makeMethodFn("PATCH"),
    post: makeMethodFn("POST"),
    put: makeMethodFn("PUT"),
    request,
    setConfig,
    sse: {
      connect: makeSseFn("CONNECT"),
      delete: makeSseFn("DELETE"),
      get: makeSseFn("GET"),
      head: makeSseFn("HEAD"),
      options: makeSseFn("OPTIONS"),
      patch: makeSseFn("PATCH"),
      post: makeSseFn("POST"),
      put: makeSseFn("PUT"),
      trace: makeSseFn("TRACE")
    },
    trace: makeMethodFn("TRACE")
  };
};

// ../sdk/src/client.gen.ts
var client = createClient(createConfig());

// ../sdk/src/sdk.gen.ts
var postV1AuthAgentsByAgentRefChallenge = (options) => {
  return (options.client ?? client).post({
    url: "/v1/auth/agents/{agentRef}/challenge",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var postV1AuthAgentsByAgentRefExchange = (options) => {
  return (options.client ?? client).post({
    url: "/v1/auth/agents/{agentRef}/exchange",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var postV1AuthAgentsByAgentRefRefresh = (options) => {
  return (options.client ?? client).post({
    url: "/v1/auth/agents/{agentRef}/refresh",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var getV1Agents = (options) => {
  return (options?.client ?? client).get({
    url: "/v1/agents",
    ...options
  });
};
var getV1AgentsByAgentRef = (options) => {
  return (options.client ?? client).get({
    url: "/v1/agents/{agentRef}",
    ...options
  });
};
var postV1AgentsByAgentRefWalletSendTransaction = (options) => {
  return (options.client ?? client).post({
    url: "/v1/agents/{agentRef}/wallet/send-transaction",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var postV1AgentsByAgentRefWalletSignTransaction = (options) => {
  return (options.client ?? client).post({
    url: "/v1/agents/{agentRef}/wallet/sign-transaction",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var postV1AgentsByAgentRefWalletSignMessage = (options) => {
  return (options.client ?? client).post({
    url: "/v1/agents/{agentRef}/wallet/sign-message",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var postV1AgentsByAgentRefWalletSignTypedData = (options) => {
  return (options.client ?? client).post({
    url: "/v1/agents/{agentRef}/wallet/sign-typed-data",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};

// src/runtime/errors.ts
var AgentAuthClientError = class extends Error {
  constructor(code, message, context) {
    super(message);
    this.name = "AgentAuthClientError";
    this.code = code;
    this.agentRef = context?.agentRef;
    this.cause = context?.cause;
  }
};
var TokenManagerError = class extends Error {
  constructor(code, message, context) {
    super(message);
    this.name = "TokenManagerError";
    this.code = code;
    this.cause = context?.cause;
  }
};
var AgentApiClientError = class extends Error {
  constructor(code, message, context) {
    super(message);
    this.name = "AgentApiClientError";
    this.code = code;
    this.agentRef = context?.agentRef;
    this.status = context?.status;
    this.details = context?.details;
    this.cause = context?.cause;
  }
};
var AgentRuntimeError = class extends Error {
  constructor(code, message, context) {
    super(message);
    this.name = "AgentRuntimeError";
    this.code = code;
    this.cause = context?.cause;
  }
};

// src/runtime/agent-api-client.ts
var DEFAULT_ERROR_MESSAGES = {
  listAgents: "Failed to list agents",
  getAgent: "Failed to fetch agent details",
  signMessage: "Failed to sign message with agent wallet",
  signTypedData: "Failed to sign typed data with agent wallet",
  signTransaction: "Failed to sign transaction with agent wallet",
  sendTransaction: "Failed to send transaction with agent wallet"
};
var AgentApiClient = class {
  constructor(options) {
    this.client = options.client;
    this.baseUrl = options.baseUrl;
    this.defaultHeaders = options.headers;
    this.defaultAgentRef = options.agentRef;
    this.fetchImpl = options.transport.asFetch();
    this.getAccessToken = options.getAccessToken;
  }
  async listAgents(options) {
    const sdkOptions = await this.makeBaseOptions(options);
    const result = await getV1Agents({
      ...sdkOptions
    });
    return this.unwrapResult(result, { operation: "listAgents" });
  }
  async getAgent(options) {
    const agentRef = this.resolveAgentRef(options?.agentRef);
    const sdkOptions = await this.makeBaseOptions(options);
    const result = await getV1AgentsByAgentRef({
      ...sdkOptions,
      path: { agentRef }
    });
    return this.unwrapResult(result, { operation: "getAgent", agentRef });
  }
  async signMessage(payload, options) {
    const agentRef = this.resolveAgentRef(options?.agentRef);
    const sdkOptions = await this.makeBaseOptions(options);
    const result = await postV1AgentsByAgentRefWalletSignMessage({
      ...sdkOptions,
      path: { agentRef },
      body: payload
    });
    return this.unwrapResult(result, { operation: "signMessage", agentRef });
  }
  async signTypedData(payload, options) {
    const agentRef = this.resolveAgentRef(options?.agentRef);
    const sdkOptions = await this.makeBaseOptions(options);
    const result = await postV1AgentsByAgentRefWalletSignTypedData({
      ...sdkOptions,
      path: { agentRef },
      body: payload
    });
    return this.unwrapResult(result, {
      operation: "signTypedData",
      agentRef
    });
  }
  async signTransaction(payload, options) {
    const agentRef = this.resolveAgentRef(options?.agentRef);
    const sdkOptions = await this.makeBaseOptions(options);
    const result = await postV1AgentsByAgentRefWalletSignTransaction({
      ...sdkOptions,
      path: { agentRef },
      body: payload
    });
    return this.unwrapResult(result, {
      operation: "signTransaction",
      agentRef
    });
  }
  async sendTransaction(payload, options) {
    const agentRef = this.resolveAgentRef(options?.agentRef);
    const sdkOptions = await this.makeBaseOptions(options);
    const result = await postV1AgentsByAgentRefWalletSendTransaction({
      ...sdkOptions,
      path: { agentRef },
      body: payload
    });
    return this.unwrapResult(result, {
      operation: "sendTransaction",
      agentRef
    });
  }
  async makeBaseOptions(options) {
    const headers = await this.buildHeaders(options?.headers);
    return {
      client: this.client,
      baseUrl: this.baseUrl,
      fetch: this.fetchImpl,
      headers,
      signal: options?.signal,
      meta: options?.meta,
      responseStyle: "fields",
      throwOnError: false
    };
  }
  async buildHeaders(overrides) {
    const token = await this.getAccessToken();
    if (!token) {
      throw new AgentApiClientError(
        "AccessTokenRequired",
        "Access token is required for agent API requests"
      );
    }
    const headers = new Headers(this.defaultHeaders);
    const normalized = token.trim();
    const bearerHeader = /^bearer\s/i.test(normalized) ? normalized : `Bearer ${normalized}`;
    headers.set("authorization", bearerHeader);
    if (overrides) {
      new Headers(overrides).forEach((value, key) => {
        headers.set(key, value);
      });
    }
    return Object.fromEntries(headers.entries());
  }
  resolveAgentRef(agentRef) {
    const value = agentRef ?? this.defaultAgentRef;
    if (!value) {
      throw new AgentApiClientError(
        "AgentRefRequired",
        "agentRef must be provided on the client or per request"
      );
    }
    return value;
  }
  unwrapResult(result, context) {
    if ("error" in result && result.error !== void 0) {
      throw new AgentApiClientError(
        "RequestFailed",
        DEFAULT_ERROR_MESSAGES[context.operation],
        {
          agentRef: context.agentRef,
          status: result.response.status,
          details: result.error
        }
      );
    }
    if (result.data === void 0) {
      throw new AgentApiClientError(
        "EmptyResponse",
        `Received empty response for ${context.operation}`,
        {
          agentRef: context.agentRef,
          status: result.response.status
        }
      );
    }
    return result.data;
  }
};

// src/runtime/agent-auth-client.ts
var DEFAULT_ERROR_MESSAGES2 = {
  challenge: "Failed to issue agent challenge",
  exchange: "Failed to exchange agent challenge",
  refresh: "Failed to refresh agent access token"
};
var AgentAuthClient = class {
  constructor(options) {
    const { agentRef, client: client2, baseUrl, fetch, headers } = options;
    if (!client2 && !baseUrl) {
      throw new AgentAuthClientError(
        "BaseUrlRequired",
        "baseUrl is required when a client instance is not provided"
      );
    }
    this.client = client2;
    this.baseUrl = baseUrl;
    this.fetchImpl = fetch;
    this.defaultAgentRef = agentRef;
    this.defaultHeaders = headers;
  }
  async requestChallenge(payload, options) {
    const config = this.buildRequestConfig(options);
    try {
      const result = await postV1AuthAgentsByAgentRefChallenge({
        ...this.makeRequestOptions(config),
        body: payload,
        path: { agentRef: config.agentRef }
      });
      return this.unwrapResult(result, {
        phase: "challenge",
        agentRef: config.agentRef
      });
    } catch (error) {
      throw this.wrapError("challenge", error, config.agentRef);
    }
  }
  async exchange(payload, options) {
    const config = this.buildRequestConfig(options);
    try {
      const result = await postV1AuthAgentsByAgentRefExchange({
        ...this.makeRequestOptions(config),
        body: payload,
        path: { agentRef: config.agentRef }
      });
      return this.unwrapResult(result, {
        phase: "exchange",
        agentRef: config.agentRef
      });
    } catch (error) {
      throw this.wrapError("exchange", error, config.agentRef);
    }
  }
  async refresh(payload, options) {
    const config = this.buildRequestConfig(options);
    try {
      const result = await postV1AuthAgentsByAgentRefRefresh({
        ...this.makeRequestOptions(config),
        body: payload,
        path: { agentRef: config.agentRef }
      });
      return this.unwrapResult(result, {
        phase: "refresh",
        agentRef: config.agentRef
      });
    } catch (error) {
      throw this.wrapError("refresh", error, config.agentRef);
    }
  }
  buildRequestConfig(options) {
    const agentRef = this.resolveAgentRef(options?.agentRef);
    return {
      agentRef,
      headers: this.mergeHeaders(options?.headers),
      signal: options?.signal,
      meta: options?.meta
    };
  }
  resolveAgentRef(agentRef) {
    const value = agentRef ?? this.defaultAgentRef;
    if (!value) {
      throw new AgentAuthClientError(
        "AgentRefRequired",
        "agentRef must be provided on the client or per request"
      );
    }
    return value;
  }
  mergeHeaders(overrides) {
    if (!this.defaultHeaders && !overrides) {
      return void 0;
    }
    const merged = new Headers();
    if (this.defaultHeaders) {
      new Headers(this.defaultHeaders).forEach((value, key) => {
        merged.set(key, value);
      });
    }
    if (overrides) {
      new Headers(overrides).forEach((value, key) => {
        merged.set(key, value);
      });
    }
    return Object.fromEntries(merged.entries());
  }
  wrapError(phase, error, agentRef) {
    if (error instanceof AgentAuthClientError) {
      return error;
    }
    return new AgentAuthClientError(
      "RequestFailed",
      DEFAULT_ERROR_MESSAGES2[phase],
      {
        agentRef,
        cause: error
      }
    );
  }
  makeRequestOptions(config) {
    return {
      client: this.client,
      baseUrl: this.baseUrl,
      fetch: this.fetchImpl,
      headers: config.headers,
      signal: config.signal,
      meta: config.meta,
      responseStyle: "fields",
      throwOnError: false
    };
  }
  unwrapResult(result, context) {
    if ("error" in result && result.error !== void 0) {
      throw new AgentAuthClientError(
        "RequestFailed",
        DEFAULT_ERROR_MESSAGES2[context.phase],
        {
          agentRef: context.agentRef,
          cause: {
            error: result.error,
            response: result.response,
            request: result.request
          }
        }
      );
    }
    if (result.data === void 0) {
      throw new AgentAuthClientError(
        "EmptyResponse",
        `Empty ${context.phase} response`,
        {
          agentRef: context.agentRef,
          cause: {
            response: result.response,
            request: result.request
          }
        }
      );
    }
    return result.data;
  }
};
var DEFAULT_CONFIG_FILENAME = ".lucid-agent.json";
var DEFAULT_API_BASE_URL = "https://api.lucid.run";
var ENV_PREFIX = "LUCID_AGENT_";
var ENV_BASE_URL = `${ENV_PREFIX}BASE_URL`;
var ENV_AGENT_REF = `${ENV_PREFIX}AGENT_REF`;
var ENV_AGENT_ID = `${ENV_PREFIX}AGENT_ID`;
var ENV_CREDENTIAL_ID = `${ENV_PREFIX}CREDENTIAL_ID`;
var ENV_REFRESH_TOKEN = `${ENV_PREFIX}REFRESH_TOKEN`;
var ENV_SCOPES = `${ENV_PREFIX}SCOPES`;
var ENV_CONFIG_PATH = `${ENV_PREFIX}CONFIG_PATH`;
async function loadAgentRuntimeConfig(options = {}) {
  const env = options.env ?? process.env;
  const cwd = options.cwd ?? process.cwd();
  const explicitPath = options.path ?? env[ENV_CONFIG_PATH];
  const configPath = explicitPath ?? DEFAULT_CONFIG_FILENAME;
  const resolvedPath = isAbsolute(configPath) ? configPath : resolve(cwd, configPath);
  const fileConfig = await readConfigFile(
    resolvedPath,
    options.readFile ?? defaultReadFile
  );
  const baseUrl = options.overrides?.baseUrl ?? env[ENV_BASE_URL] ?? fileConfig?.apiBaseUrl ?? DEFAULT_API_BASE_URL;
  const agentRef = options.overrides?.agentRef ?? env[ENV_AGENT_REF] ?? env[ENV_AGENT_ID] ?? fileConfig?.agentRef ?? fileConfig?.agentId;
  const credentialId = options.overrides?.credentialId ?? env[ENV_CREDENTIAL_ID] ?? fileConfig?.credentialId;
  const refreshToken = options.overrides?.refreshToken ?? env[ENV_REFRESH_TOKEN] ?? fileConfig?.refreshToken;
  const scopes = normalizeScopes(options.overrides?.scopes) ?? normalizeScopes(env[ENV_SCOPES]) ?? normalizeScopes(fileConfig?.scopes);
  validateRequired("agentRef", agentRef, resolvedPath);
  validateRequired("credentialId", credentialId, resolvedPath);
  const config = {
    baseUrl,
    agentRef,
    credentialId,
    refreshToken: refreshToken || void 0,
    scopes: scopes ?? void 0
  };
  return {
    config,
    sourcePath: fileConfig ? resolvedPath : void 0,
    fileConfig
  };
}
var defaultReadFile = (path) => readFile(path, "utf8");
async function readConfigFile(path, reader) {
  try {
    const contents = await reader(path);
    if (!contents.trim()) {
      return {};
    }
    try {
      const parsed = JSON.parse(contents);
      return parsed;
    } catch (error) {
      throw new AgentRuntimeError(
        "ConfigurationError",
        `Failed to parse config file at ${path}`,
        { cause: error }
      );
    }
  } catch (error) {
    if (isNodeError(error) && (error.code === "ENOENT" || error.code === "ENOTDIR")) {
      return null;
    }
    throw new AgentRuntimeError(
      "ConfigurationError",
      `Unable to read config file at ${path}`,
      { cause: error }
    );
  }
}
function normalizeScopes(value) {
  if (!value) {
    return void 0;
  }
  if (Array.isArray(value)) {
    const scopes = value.filter((scope) => typeof scope === "string").map((scope) => scope.trim()).filter(Boolean);
    return scopes.length ? scopes : void 0;
  }
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) {
      return void 0;
    }
    try {
      const parsed = JSON.parse(trimmed);
      if (Array.isArray(parsed)) {
        return normalizeScopes(parsed);
      }
    } catch {
    }
    const scopes = trimmed.split(",").map((scope) => scope.trim()).filter(Boolean);
    return scopes.length ? scopes : void 0;
  }
  return void 0;
}
function validateRequired(field, value, path) {
  if (!value) {
    throw new AgentRuntimeError(
      "ConfigurationError",
      `Missing required configuration value "${field}". Checked ${path} and environment overrides.`
    );
  }
}
function isNodeError(error) {
  return typeof error === "object" && error !== null && "code" in error;
}

// src/runtime/storage/memory-adapter.ts
var MemoryStorageAdapter = class {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  async get(key) {
    return this.store.has(key) ? this.store.get(key) : null;
  }
  async set(key, value) {
    this.store.set(key, value);
  }
  async delete(key) {
    this.store.delete(key);
  }
};
var createMemoryStorageAdapter = () => new MemoryStorageAdapter();

// src/runtime/token-manager.ts
var DEFAULT_STORAGE_KEY = "agent-auth:token-bundle";
var DEFAULT_REFRESH_LEAD_TIME_MS = 3e4;
var normalizeDate = (value) => value instanceof Date ? value : new Date(value);
var cloneSnapshot = (snapshot) => ({
  accessToken: snapshot.accessToken,
  accessTokenExpiresAt: new Date(snapshot.accessTokenExpiresAt.getTime()),
  refreshToken: snapshot.refreshToken,
  refreshTokenExpiresAt: new Date(snapshot.refreshTokenExpiresAt.getTime()),
  revocationNonce: snapshot.revocationNonce,
  scopes: snapshot.scopes ? [...snapshot.scopes] : void 0
});
var serializeSnapshot = (snapshot) => ({
  version: 1,
  value: {
    accessToken: snapshot.accessToken,
    accessTokenExpiresAt: snapshot.accessTokenExpiresAt.toISOString(),
    refreshToken: snapshot.refreshToken,
    refreshTokenExpiresAt: snapshot.refreshTokenExpiresAt.toISOString(),
    revocationNonce: snapshot.revocationNonce,
    scopes: snapshot.scopes ? [...snapshot.scopes] : void 0
  }
});
var deserializeSnapshot = (serialized) => ({
  accessToken: serialized.value.accessToken,
  accessTokenExpiresAt: normalizeDate(serialized.value.accessTokenExpiresAt),
  refreshToken: serialized.value.refreshToken,
  refreshTokenExpiresAt: normalizeDate(
    serialized.value.refreshTokenExpiresAt
  ),
  revocationNonce: serialized.value.revocationNonce ?? void 0,
  scopes: serialized.value.scopes ? [...serialized.value.scopes] : void 0
});
var TokenManager = class {
  constructor(options = {}) {
    this.tokens = null;
    this.refreshTimer = null;
    this.refreshPromise = null;
    this.storage = options.storage ?? new MemoryStorageAdapter();
    this.storageKey = options.storageKey ?? DEFAULT_STORAGE_KEY;
    this.refreshLeadTimeMs = options.refreshLeadTimeMs ?? DEFAULT_REFRESH_LEAD_TIME_MS;
    this.now = options.now ?? (() => Date.now());
  }
  async hydrate() {
    const raw = await this.storage.get(this.storageKey);
    if (!raw) {
      return null;
    }
    let parsed;
    try {
      parsed = JSON.parse(raw);
    } catch (error) {
      throw new TokenManagerError(
        "StorageFailure",
        "Failed to parse stored token bundle",
        { cause: error }
      );
    }
    if (parsed.version !== 1) {
      throw new TokenManagerError(
        "StorageFailure",
        `Unsupported token bundle version: ${parsed.version}`
      );
    }
    this.tokens = deserializeSnapshot(parsed);
    return cloneSnapshot(this.tokens);
  }
  getSnapshot() {
    return this.tokens ? cloneSnapshot(this.tokens) : null;
  }
  getCachedAccessToken() {
    if (!this.tokens) {
      return null;
    }
    return {
      token: this.tokens.accessToken,
      expiresAt: new Date(this.tokens.accessTokenExpiresAt.getTime()),
      scopes: this.tokens.scopes ? [...this.tokens.scopes] : void 0,
      refreshToken: this.tokens.refreshToken,
      refreshTokenExpiresAt: new Date(
        this.tokens.refreshTokenExpiresAt.getTime()
      ),
      revocationNonce: this.tokens.revocationNonce
    };
  }
  async setTokens(bundle) {
    const normalized = this.normalizeBundle(bundle);
    this.tokens = normalized;
    const serialized = serializeSnapshot(normalized);
    await this.storage.set(this.storageKey, JSON.stringify(serialized));
    return cloneSnapshot(normalized);
  }
  async clear() {
    this.tokens = null;
    this.clearScheduledRefresh();
    await this.storage.delete(this.storageKey);
  }
  scheduleRefresh(trigger) {
    if (!this.tokens) {
      throw new TokenManagerError(
        "TokensUnavailable",
        "Cannot schedule refresh without cached tokens"
      );
    }
    this.clearScheduledRefresh();
    const targetTime = this.tokens.accessTokenExpiresAt.getTime() - this.refreshLeadTimeMs;
    const delay = Math.max(0, targetTime - this.now());
    let cancelled = false;
    const run = () => {
      void this.withRefreshLock(async () => {
        if (cancelled) {
          return;
        }
        const next = await trigger();
        await this.setTokens(next);
      }).catch(() => {
      });
    };
    this.refreshTimer = setTimeout(run, delay);
    return {
      cancel: () => {
        cancelled = true;
        this.clearScheduledRefresh();
      }
    };
  }
  async withRefreshLock(fn) {
    if (this.refreshPromise) {
      return this.refreshPromise;
    }
    const promise = (async () => {
      try {
        return await fn();
      } finally {
        this.refreshPromise = null;
      }
    })();
    this.refreshPromise = promise;
    return promise;
  }
  normalizeBundle(bundle) {
    const accessTokenExpiresAt = normalizeDate(bundle.accessTokenExpiresAt);
    const refreshTokenExpiresAt = normalizeDate(bundle.refreshTokenExpiresAt);
    return {
      accessToken: bundle.accessToken,
      accessTokenExpiresAt,
      refreshToken: bundle.refreshToken,
      refreshTokenExpiresAt,
      revocationNonce: bundle.revocationNonce ?? void 0,
      scopes: bundle.scopes ? [...bundle.scopes] : void 0
    };
  }
  clearScheduledRefresh() {
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
  }
};

// src/runtime/transport/http-transport.ts
var HttpTransportError = class extends Error {
  constructor(message, options) {
    super(message);
    this.name = "HttpTransportError";
    this.code = options.code;
    this.url = options.url;
    this.status = options.status;
    this.response = options.response;
    this.data = options.data;
    this.cause = options.cause;
  }
};
var isHttpTransportError = (error) => error instanceof HttpTransportError;

// src/runtime/transport/fetch-transport.ts
var ABSOLUTE_URL_PATTERN = /^[a-zA-Z][a-zA-Z\d+\-.]*:/;
var DEFAULT_METHOD = "GET";
var DEFAULT_RESPONSE_TYPE = "json";
var resolveUrl = (baseUrl, input, query) => {
  let target = null;
  if (input instanceof URL) {
    target = new URL(input.toString());
  } else if (ABSOLUTE_URL_PATTERN.test(input)) {
    target = new URL(input);
  } else if (baseUrl) {
    target = new URL(input, baseUrl);
  }
  if (!target) {
    const raw = typeof input === "string" ? input : input.toString();
    throw new HttpTransportError(
      "Failed to resolve request URL. Provide an absolute URL or configure a baseUrl.",
      {
        code: "ConfigurationError",
        url: raw
      }
    );
  }
  if (query) {
    const params = new URLSearchParams(target.search);
    for (const [key, value] of Object.entries(query)) {
      if (value === void 0 || value === null) {
        continue;
      }
      const normalized = typeof value === "boolean" ? value ? "true" : "false" : String(value);
      params.set(key, normalized);
    }
    target.search = params.toString();
  }
  return target.toString();
};
var mergeHeaders2 = (...sources) => {
  const result = new Headers();
  for (const source of sources) {
    if (!source) {
      continue;
    }
    const headers = new Headers(source);
    headers.forEach((value, key) => {
      result.set(key, value);
    });
  }
  return result;
};
var createAbortBundle = (signal, timeoutMs) => {
  if (timeoutMs === void 0 || timeoutMs === null) {
    return {
      signal,
      cleanup: void 0,
      timedOut: () => false
    };
  }
  const controller = new AbortController();
  let timedOut = false;
  let timeoutId;
  let abortHandler;
  if (signal) {
    if (signal.aborted) {
      controller.abort(getSignalReason(signal));
    } else {
      abortHandler = () => {
        if (!controller.signal.aborted) {
          controller.abort(getSignalReason(signal));
        }
      };
      signal.addEventListener("abort", abortHandler, { once: true });
    }
  }
  timeoutId = setTimeout(() => {
    if (!controller.signal.aborted) {
      timedOut = true;
      controller.abort(new Error("Request timed out"));
    }
  }, timeoutMs);
  const cleanup = () => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (signal && abortHandler) {
      signal.removeEventListener("abort", abortHandler);
    }
  };
  return {
    signal: controller.signal,
    cleanup,
    timedOut: () => timedOut
  };
};
var getSignalReason = (signal) => {
  if ("reason" in signal) {
    return signal.reason;
  }
  return void 0;
};
var isAbortError = (error) => {
  if (typeof DOMException !== "undefined" && error instanceof DOMException) {
    return error.name === "AbortError";
  }
  return error instanceof Error && error.name === "AbortError";
};
var parseJson = async (response, url) => {
  if (response.status === 204 || response.status === 205) {
    return null;
  }
  const contentLength = response.headers.get("content-length");
  if (contentLength === "0") {
    return null;
  }
  const text = await response.text();
  if (!text) {
    return null;
  }
  try {
    return JSON.parse(text);
  } catch (error) {
    throw new HttpTransportError("Failed to parse JSON response", {
      code: "ParseError",
      url,
      response,
      cause: error
    });
  }
};
var parseResponse = async (response, type, url) => {
  switch (type) {
    case "json":
      return parseJson(response, url);
    case "text":
      return await response.text();
    case "arrayBuffer":
      return await response.arrayBuffer();
    case "blob":
      return await response.blob();
    case "stream":
      return response.body ?? null;
    case "response":
      return response;
    default: {
      const exhaustive = type;
      throw new Error(`Unsupported response type: ${exhaustive}`);
    }
  }
};
var createFetchTransport = (options = {}) => {
  const fetchImpl = options.fetch ?? globalThis.fetch;
  if (typeof fetchImpl !== "function") {
    throw new Error(
      "Unable to create fetch transport: no fetch implementation provided."
    );
  }
  const baseUrl = options.baseUrl;
  const defaultHeaders2 = options.defaultHeaders;
  const defaultTimeoutMs = options.defaultTimeoutMs;
  const request = async (requestOptions) => {
    const method = (requestOptions.method ?? DEFAULT_METHOD).toUpperCase();
    if (requestOptions.json !== void 0 && requestOptions.body !== void 0 && requestOptions.body !== null) {
      const raw = typeof requestOptions.url === "string" ? requestOptions.url : requestOptions.url.toString();
      throw new HttpTransportError(
        "Provide either `json` or `body` when issuing a request.",
        {
          code: "ConfigurationError",
          url: raw
        }
      );
    }
    const resolvedUrl = resolveUrl(
      baseUrl,
      requestOptions.url,
      requestOptions.query
    );
    const headers = mergeHeaders2(defaultHeaders2, requestOptions.headers);
    let requestBody;
    if (requestOptions.body !== void 0 && requestOptions.body !== null) {
      requestBody = requestOptions.body;
    }
    if (requestOptions.json !== void 0) {
      requestBody = JSON.stringify(requestOptions.json);
      if (!headers.has("content-type")) {
        headers.set("content-type", "application/json");
      }
    }
    const timeoutMs = requestOptions.timeoutMs ?? defaultTimeoutMs;
    const abortBundle = createAbortBundle(
      requestOptions.signal,
      timeoutMs
    );
    const fetchInit = {
      method,
      headers,
      signal: abortBundle.signal ?? requestOptions.signal
    };
    if (requestBody !== void 0) {
      fetchInit.body = requestBody;
    }
    const parseAs = requestOptions.parseAs ?? DEFAULT_RESPONSE_TYPE;
    const throwOnError = requestOptions.throwOnError ?? true;
    let response;
    try {
      response = await fetchImpl(resolvedUrl, fetchInit);
      const responseUrl = response.url || resolvedUrl;
      const parseTarget = parseAs === "response" || parseAs === "stream" ? response : response.clone();
      const data = await parseResponse(parseTarget, parseAs, responseUrl);
      if (!response.ok && throwOnError) {
        throw new HttpTransportError(
          `Request to ${responseUrl} failed with status ${response.status}`,
          {
            code: "HttpError",
            url: responseUrl,
            status: response.status,
            response,
            data
          }
        );
      }
      return {
        status: response.status,
        headers: response.headers,
        data,
        raw: response,
        url: responseUrl
      };
    } catch (error) {
      if (error instanceof HttpTransportError) {
        throw error;
      }
      if (abortBundle.timedOut()) {
        throw new HttpTransportError("Request timed out", {
          code: "TimeoutError",
          url: response?.url ?? resolvedUrl,
          response,
          cause: error
        });
      }
      if (isAbortError(error)) {
        throw new HttpTransportError("Request aborted", {
          code: "AbortError",
          url: response?.url ?? resolvedUrl,
          response,
          cause: error
        });
      }
      throw new HttpTransportError("Network request failed", {
        code: "NetworkError",
        url: response?.url ?? resolvedUrl,
        response,
        cause: error
      });
    } finally {
      abortBundle.cleanup?.();
    }
  };
  const asFetch = () => {
    const fetchFn = (async (input, init) => {
      const overrides = init ?? {};
      const headers = new Headers();
      let url;
      let method;
      let body;
      let signal;
      if (input instanceof Request) {
        url = input.url;
        method = input.method;
        body = input.body ?? void 0;
        signal = input.signal ?? void 0;
        new Headers(input.headers).forEach((value, key) => {
          headers.set(key, value);
        });
      } else {
        url = input;
      }
      if (overrides.headers) {
        new Headers(overrides.headers).forEach((value, key) => {
          headers.set(key, value);
        });
      }
      method = overrides.method ?? method ?? DEFAULT_METHOD;
      if (overrides.body !== void 0) {
        body = overrides.body;
      }
      signal = overrides.signal ?? signal;
      const response = await request({
        url,
        method,
        headers,
        body: body ?? void 0,
        signal,
        parseAs: "response",
        throwOnError: false,
        timeoutMs: defaultTimeoutMs
      });
      return response.data;
    });
    const globalFetch = globalThis.fetch;
    if (globalFetch && typeof globalFetch.preconnect === "function") {
      fetchFn.preconnect = globalFetch.preconnect.bind(globalFetch);
    } else {
      const noopPreconnect = async (..._args) => {
      };
      fetchFn.preconnect = noopPreconnect;
    }
    return fetchFn;
  };
  return {
    request,
    asFetch
  };
};

// src/runtime/agent-runtime.ts
var DEFAULT_REFRESH_LEAD_TIME_MS2 = 3e4;
var parseDate = (value) => value instanceof Date ? value : new Date(value);
var resolveRefreshExpiry = (response) => {
  const candidate = (
    // accommodate legacy schema name
    response.refresh_token_expires_at ?? response.refresh_expires_at
  );
  if (!candidate) {
    throw new AgentRuntimeError(
      "AuthenticationFailed",
      "Refresh token expiry is missing in exchange response"
    );
  }
  return candidate;
};
var AgentRuntime = class _AgentRuntime {
  constructor(options) {
    this.handlers = {
      authenticated: /* @__PURE__ */ new Set(),
      tokenRefreshed: /* @__PURE__ */ new Set(),
      refreshFailed: /* @__PURE__ */ new Set(),
      tokensCleared: /* @__PURE__ */ new Set()
    };
    this.refreshTimer = null;
    this.config = options.config;
    this.wallet = options.wallet;
    this.transport = options.transport;
    this.authClient = options.authClient;
    this.tokenManager = options.tokenManager;
    this.refreshLeadTimeMs = options.refreshLeadTimeMs;
    this.now = options.now;
    this.api = options.apiClient ?? new AgentApiClient({
      transport: this.transport,
      baseUrl: this.config.baseUrl,
      agentRef: this.config.agentRef,
      getAccessToken: async () => this.tokenManager.getCachedAccessToken()?.token ?? null
    });
  }
  static async fromConfig(options) {
    const { config, wallet } = options;
    if (!config?.baseUrl) {
      throw new AgentRuntimeError(
        "ConfigurationError",
        "baseUrl is required"
      );
    }
    if (!config.agentRef) {
      throw new AgentRuntimeError(
        "ConfigurationError",
        "agentRef is required"
      );
    }
    if (!config.credentialId) {
      throw new AgentRuntimeError(
        "ConfigurationError",
        "credentialId is required"
      );
    }
    if (!wallet?.signer) {
      throw new AgentRuntimeError(
        "ConfigurationError",
        "wallet signer is required"
      );
    }
    const fetchImpl = options.fetch ?? globalThis.fetch;
    if (!fetchImpl) {
      throw new AgentRuntimeError(
        "ConfigurationError",
        "No fetch implementation available. Provide one via options.fetch."
      );
    }
    const refreshLeadTimeMs = options.refreshLeadTimeMs ?? DEFAULT_REFRESH_LEAD_TIME_MS2;
    const now = options.now ?? (() => Date.now());
    const transport = options.transport ?? createFetchTransport({
      baseUrl: config.baseUrl,
      fetch: fetchImpl,
      defaultHeaders: options.headers
    });
    const authClient = options.authClient ?? new AgentAuthClient({
      agentRef: config.agentRef,
      baseUrl: config.baseUrl,
      fetch: transport.asFetch(),
      headers: options.headers
    });
    const tokenManager = options.tokenManager ?? new TokenManager({
      storage: options.storage,
      refreshLeadTimeMs,
      now
    });
    const runtime = new _AgentRuntime({
      config,
      wallet,
      transport,
      authClient,
      apiClient: options.apiClient,
      tokenManager,
      refreshLeadTimeMs,
      now
    });
    await runtime.initialize();
    return runtime;
  }
  static async load(options) {
    const { loader, ...runtimeOptions } = options;
    const loadedConfig = await loadAgentRuntimeConfig(loader);
    const runtime = await _AgentRuntime.fromConfig({
      ...runtimeOptions,
      config: loadedConfig.config
    });
    return {
      ...loadedConfig,
      runtime
    };
  }
  async authenticate() {
    const challenge = await this.authClient.requestChallenge({
      credential_id: this.config.credentialId,
      scopes: this.config.scopes
    });
    const signature = await this.wallet.signer.signChallenge(
      challenge.challenge
    );
    const exchange = await this.authClient.exchange({
      challenge_id: challenge.challenge.id,
      signature,
      credential_id: this.config.credentialId
    });
    const snapshot = await this.storeTokens(exchange);
    this.emit("authenticated", snapshot);
    return snapshot;
  }
  async ensureAccessToken() {
    const cached = this.tokenManager.getCachedAccessToken();
    if (!cached) {
      const session = await this.authenticate();
      return session.accessToken;
    }
    const timeToExpiry = cached.expiresAt.getTime() - this.now();
    if (timeToExpiry <= 0 || timeToExpiry <= this.refreshLeadTimeMs) {
      const snapshot = await this.refreshTokens();
      return snapshot.accessToken;
    }
    return cached.token;
  }
  async shutdown() {
    this.clearRefreshTimer();
  }
  on(event, handler) {
    const set = this.handlers[event];
    set.add(handler);
    return () => {
      set.delete(handler);
    };
  }
  async clearTokens(reason) {
    this.clearRefreshTimer();
    await this.tokenManager.clear();
    this.emit("tokensCleared", { reason });
  }
  async initialize() {
    const snapshot = await this.tokenManager.hydrate();
    if (snapshot) {
      this.scheduleRefresh(this.snapshotToSession(snapshot));
      return;
    }
    if (this.config.refreshToken) {
      try {
        const refreshed = await this.authClient.refresh({
          refresh_token: this.config.refreshToken
        });
        const session = await this.storeTokens(refreshed);
        this.emit("authenticated", session);
      } catch (error) {
        this.emit("refreshFailed", { error });
      }
    }
  }
  async refreshTokens() {
    return this.tokenManager.withRefreshLock(async () => {
      const snapshot = this.tokenManager.getSnapshot();
      if (!snapshot) {
        throw new AgentRuntimeError(
          "TokensUnavailable",
          "Cannot refresh tokens without an active session"
        );
      }
      try {
        const refreshed = await this.authClient.refresh({
          refresh_token: snapshot.refreshToken
        });
        const updated = await this.storeTokens(refreshed);
        this.emit("tokenRefreshed", updated);
        return updated;
      } catch (error) {
        this.emit("refreshFailed", { error });
        throw new AgentRuntimeError(
          "RefreshFailed",
          "Failed to refresh access token",
          { cause: error }
        );
      }
    });
  }
  async storeTokens(response) {
    const refreshTokenExpiresAt = resolveRefreshExpiry(response);
    const scoped = response.credential?.scopes ?? void 0;
    const snapshot = await this.tokenManager.setTokens({
      accessToken: response.access_token,
      accessTokenExpiresAt: parseDate(response.expires_at),
      refreshToken: response.refresh_token,
      refreshTokenExpiresAt: parseDate(refreshTokenExpiresAt),
      revocationNonce: response.credential?.revocation_nonce ?? void 0,
      scopes: scoped
    });
    const session = this.snapshotToSession(snapshot);
    this.scheduleRefresh(session);
    return session;
  }
  scheduleRefresh(snapshot) {
    this.clearRefreshTimer();
    const target = snapshot.expiresAt.getTime() - this.refreshLeadTimeMs;
    const delay = Math.max(0, target - this.now());
    this.refreshTimer = setTimeout(() => {
      void this.refreshTokens().catch(() => {
      });
    }, delay);
  }
  clearRefreshTimer() {
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
  }
  emit(event, payload) {
    const listeners = this.handlers[event];
    for (const handler of listeners) {
      try {
        handler(payload);
      } catch {
      }
    }
  }
  snapshotToSession(snapshot) {
    return {
      accessToken: snapshot.accessToken,
      refreshToken: snapshot.refreshToken,
      expiresAt: snapshot.accessTokenExpiresAt,
      refreshTokenExpiresAt: snapshot.refreshTokenExpiresAt,
      scopes: snapshot.scopes
    };
  }
};

// src/runtime/transport/undici-transport.ts
var createUndiciTransport = (options = {}) => {
  const { dispatcher, fetch: fetchOption, ...rest } = options;
  if (!dispatcher) {
    return createFetchTransport({
      ...rest,
      fetch: fetchOption
    });
  }
  const baseFetch = fetchOption ?? globalThis.fetch;
  if (typeof baseFetch !== "function") {
    throw new Error(
      "Unable to create undici transport: provide the undici fetch implementation."
    );
  }
  const fetchWithDispatcher = ((input, init) => baseFetch(input, {
    ...init ?? {},
    dispatcher
  }));
  if ("preconnect" in baseFetch) {
    const preconnect = baseFetch.preconnect;
    if (typeof preconnect === "function") {
      fetchWithDispatcher.preconnect = preconnect.bind(baseFetch);
    }
  }
  return createFetchTransport({
    ...rest,
    fetch: fetchWithDispatcher
  });
};

// src/runtime/wallet/base-connector.ts
var DEFAULT_NORMALIZATION_OPTIONS = {
  stableStringify: true
};
var normalizeChallenge = (challenge, options = DEFAULT_NORMALIZATION_OPTIONS) => {
  const issuedAt = toDate(challenge.issued_at);
  const expiresAt = toDate(challenge.expires_at);
  const scopes = Array.isArray(challenge.scopes) ? challenge.scopes.filter((value) => typeof value === "string") : [];
  return {
    id: challenge.id,
    credentialId: challenge.credential_id ?? null,
    payload: challenge.payload,
    payloadHash: challenge.payload_hash,
    nonce: challenge.nonce,
    scopes,
    issuedAt,
    expiresAt,
    serverSignature: challenge.server_signature ?? null,
    message: resolveChallengeMessage(challenge.payload, options)
  };
};
var toDate = (value) => value instanceof Date ? value : new Date(value);
var resolveChallengeMessage = (payload, options) => {
  if (!payload) {
    return null;
  }
  if (typeof payload === "string") {
    return payload;
  }
  if (typeof payload !== "object") {
    return null;
  }
  const record = payload;
  if (typeof record.message === "string") {
    return record.message;
  }
  if (typeof record.payload === "string") {
    return record.payload;
  }
  if (Array.isArray(record.parts)) {
    const joined = record.parts.map(
      (item) => typeof item === "string" ? item : typeof item === "object" && item && "text" in item ? String(item.text ?? "") : ""
    ).join("");
    if (joined) {
      return joined;
    }
  }
  try {
    return options.stableStringify !== false ? stableJsonStringify(record) : JSON.stringify(record);
  } catch {
    return null;
  }
};
var stableJsonStringify = (value) => {
  if (value === null || typeof value !== "object") {
    if (typeof value === "bigint") {
      return JSON.stringify(value.toString());
    }
    return JSON.stringify(value);
  }
  if (Array.isArray(value)) {
    const mapped = value.map((item) => stableJsonStringify(item));
    return `[${mapped.join(",")}]`;
  }
  const entries = Object.entries(value).filter(([, entryValue]) => entryValue !== void 0).sort(([a], [b]) => a < b ? -1 : a > b ? 1 : 0);
  const serialized = entries.map(([key, entryValue]) => {
    const normalizedEntry = typeof entryValue === "bigint" ? entryValue.toString() : entryValue;
    return `${JSON.stringify(key)}:${stableJsonStringify(normalizedEntry)}`;
  }).join(",");
  return `{${serialized}}`;
};
var extractSignature = (payload) => {
  if (!payload) {
    return null;
  }
  if (typeof payload === "string") {
    return payload;
  }
  if (typeof payload !== "object") {
    return null;
  }
  const record = payload;
  const signed = record.signed ?? record.signature ?? payload;
  if (typeof signed === "string") {
    return signed;
  }
  if (signed && typeof signed === "object" && "signature" in signed && typeof signed.signature === "string") {
    return signed.signature;
  }
  return null;
};
var extractWalletMetadata = (payload) => {
  if (!payload || typeof payload !== "object") {
    return null;
  }
  const record = payload;
  if (!record.wallet || typeof record.wallet !== "object") {
    return null;
  }
  const wallet = record.wallet;
  const account = record.account && typeof record.account === "object" ? record.account : void 0;
  return {
    id: typeof wallet.id === "string" ? wallet.id : null,
    address: typeof wallet.address === "string" ? wallet.address : null,
    chain: typeof wallet.chain === "string" ? wallet.chain : null,
    chainType: typeof wallet.chainType === "string" ? wallet.chainType : null,
    provider: typeof wallet.provider === "string" ? wallet.provider : null,
    caip2: typeof wallet.caip2 === "string" ? wallet.caip2 : null,
    accountId: typeof account?.id === "string" ? account.id : null,
    label: typeof account?.displayName === "string" ? account.displayName : typeof wallet.label === "string" ? wallet.label : null
  };
};
var detectMessageEncoding = (message) => {
  if (/^0x[0-9a-fA-F]*$/.test(message.trim())) {
    return "hex";
  }
  return "utf-8";
};

// src/runtime/wallet/server-orchestrator-connector.ts
var DEFAULT_AUTHORIZATION_CONTEXT = {
  reason: "lucid.agent.auth.exchange"
};
var ServerOrchestratorMissingAccessTokenError = class extends Error {
  constructor() {
    super(
      "Server orchestrator connector requires a bearer token. Call setAccessToken() first."
    );
    this.name = "ServerOrchestratorMissingAccessTokenError";
  }
};
var ServerOrchestratorWalletConnector = class {
  constructor(options) {
    this.cachedMetadata = null;
    if (!options?.baseUrl) {
      throw new Error(
        "ServerOrchestratorWalletConnector requires a baseUrl option"
      );
    }
    if (!options.agentRef) {
      throw new Error(
        "ServerOrchestratorWalletConnector requires an agentRef option"
      );
    }
    const fetchCandidate = options.fetch ?? globalThis.fetch;
    if (!fetchCandidate) {
      throw new Error(
        "No fetch implementation available. Provide one via options.fetch."
      );
    }
    this.baseUrl = options.baseUrl.replace(/\/?$/, "");
    this.agentRef = options.agentRef;
    this.fetchImpl = fetchCandidate;
    this.defaultHeaders = options.headers;
    this.accessToken = options.accessToken ?? null;
    this.authorizationContext = {
      ...DEFAULT_AUTHORIZATION_CONTEXT,
      ...options.authorizationContext
    };
  }
  setAccessToken(token) {
    this.accessToken = token ?? null;
  }
  async signChallenge(challenge) {
    const token = this.accessToken;
    if (!token) {
      throw new ServerOrchestratorMissingAccessTokenError();
    }
    const normalized = normalizeChallenge(challenge);
    const message = normalized.message;
    if (!message) {
      throw new Error(
        "Server orchestrator challenge payload did not include a signable message"
      );
    }
    const response = await this.fetchImpl(
      buildWalletSignUrl(this.baseUrl, this.agentRef),
      {
        method: "POST",
        headers: this.buildHeaders(token),
        body: JSON.stringify({
          message,
          encoding: detectMessageEncoding(message),
          idempotency_key: normalized.id,
          authorization_context: {
            ...this.authorizationContext,
            challenge_id: normalized.id
          }
        })
      }
    );
    const rawBody = await response.text();
    if (!response.ok) {
      throw buildSigningError(response, rawBody);
    }
    const parsed = safeJsonParse(rawBody);
    const signature = extractSignature(parsed);
    if (!signature) {
      throw new Error(
        "Server orchestrator response did not contain a signature field"
      );
    }
    this.cachedMetadata = extractWalletMetadata(parsed);
    return signature;
  }
  async getWalletMetadata() {
    return this.cachedMetadata;
  }
  supportsCaip2(_) {
    return true;
  }
  async getAddress() {
    return this.cachedMetadata?.address ?? null;
  }
  buildHeaders(token) {
    const headers = new Headers(this.defaultHeaders);
    headers.set("content-type", "application/json");
    headers.set("authorization", normalizeAuthorizationHeader(token));
    return Object.fromEntries(headers.entries());
  }
};
var buildWalletSignUrl = (baseUrl, agentRef) => `${baseUrl}/v1/agents/${encodeURIComponent(agentRef)}/wallet/sign-message`;
var normalizeAuthorizationHeader = (token) => /^bearer\s/i.test(token) ? token : `Bearer ${token}`;
var buildSigningError = (response, body) => {
  const details = safeJsonParse(body);
  const serialized = details && typeof details === "object" ? JSON.stringify(details) : body;
  return new Error(
    `Server wallet signing failed: ${response.status} ${response.statusText}${serialized ? ` - ${serialized}` : ""}`
  );
};
var safeJsonParse = (text) => {
  if (!text) return null;
  try {
    return JSON.parse(text);
  } catch {
    return text;
  }
};

// src/runtime/create-wallet.ts
var DEFAULT_BASE_URL = "https://lucid.daydream.systems";
var createWallet = async (options) => {
  const fetchImpl = options.fetch ?? globalThis.fetch;
  if (!fetchImpl) {
    throw new Error(
      "createWallet was invoked without a fetch implementation. Provide one via options.fetch."
    );
  }
  const runtimeConfig = resolveRuntimeConfig(options.config);
  const serverOverrides = options.wallet?.server ?? inferServerOverridesFromEnv();
  const connector = options.wallet?.connector ?? createDefaultServerConnector({
    config: runtimeConfig,
    fetch: fetchImpl,
    server: serverOverrides
  });
  const runtime = await AgentRuntime.fromConfig({
    config: runtimeConfig,
    wallet: { signer: connector },
    fetch: fetchImpl,
    transport: options.transport,
    storage: options.storage,
    headers: options.headers
  });
  const syncConnectorToken = (token) => {
    if (isAccessTokenAware(connector)) {
      connector.setAccessToken(token);
    }
  };
  runtime.on("authenticated", (event) => {
    syncConnectorToken(event.accessToken);
  });
  runtime.on("tokenRefreshed", (event) => {
    syncConnectorToken(event.accessToken);
  });
  if (options.events) {
    registerInitialEventHandlers(runtime, options.events);
  }
  const walletClient = {
    runtime,
    connector,
    authenticate: () => runtime.authenticate(),
    ensureAccessToken: () => runtime.ensureAccessToken(),
    signMessage: (payload) => runtime.api.signMessage(payload),
    signTypedData: (payload) => runtime.api.signTypedData(payload),
    signTransaction: (payload) => runtime.api.signTransaction(payload),
    sendTransaction: (payload) => runtime.api.sendTransaction(payload),
    getWalletMetadata: () => connector.getWalletMetadata(),
    getAddress: async () => {
      if (typeof connector.getAddress === "function") {
        return connector.getAddress();
      }
      const metadata = await connector.getWalletMetadata();
      return metadata?.address ?? null;
    },
    on: (event, handler) => runtime.on(event, handler),
    shutdown: () => runtime.shutdown()
  };
  return walletClient;
};
var createDefaultServerConnector = (options) => {
  const { config, fetch, server } = options;
  const baseUrl = server?.baseUrl ?? config.baseUrl ?? DEFAULT_BASE_URL;
  return new ServerOrchestratorWalletConnector({
    baseUrl,
    agentRef: config.agentRef,
    fetch,
    headers: server?.headers,
    accessToken: server?.accessToken ?? null,
    authorizationContext: server?.authorizationContext
  });
};
var isAccessTokenAware = (connector) => typeof connector.setAccessToken === "function";
var registerInitialEventHandlers = (runtime, events) => {
  for (const [event, handlers] of Object.entries(events)) {
    if (!handlers) continue;
    const list = Array.isArray(handlers) ? handlers : [handlers];
    for (const handler of list) {
      runtime.on(event, handler);
    }
  }
};
var resolveRuntimeConfig = (overrides) => {
  const rawBaseUrl = overrides?.baseUrl ?? process.env.LUCID_BASE_URL ?? DEFAULT_BASE_URL;
  const baseUrl = rawBaseUrl.trim() || DEFAULT_BASE_URL;
  const agentRef = overrides?.agentRef ?? process.env.LUCID_AGENT_REF;
  if (!agentRef) {
    throw new Error(
      "createWallet requires an agent ref. Provide config.agentRef or set LUCID_AGENT_REF."
    );
  }
  const credentialId = overrides?.credentialId ?? process.env.LUCID_AGENT_CREDENTIAL;
  if (!credentialId) {
    throw new Error(
      "createWallet requires an agent credential. Provide config.credentialId or set LUCID_AGENT_CREDENTIAL."
    );
  }
  const refreshToken = overrides?.refreshToken ?? process.env.LUCID_AGENT_REFRESH_TOKEN ?? void 0;
  const scopes = overrides?.scopes ?? parseScopes(process.env.LUCID_AGENT_SCOPES);
  return {
    baseUrl,
    agentRef,
    credentialId,
    refreshToken,
    scopes
  };
};
var parseScopes = (raw) => {
  if (!raw) {
    return void 0;
  }
  const tokens = raw.split(/[,\s]+/g).map((token) => token.trim()).filter(Boolean);
  return tokens.length ? tokens : void 0;
};
var inferServerOverridesFromEnv = () => {
  const baseUrl = process.env.LUCID_SERVER_URL;
  const accessToken = process.env.LUCID_SERVER_ACCESS_TOKEN;
  if (!baseUrl && !accessToken) {
    return void 0;
  }
  return {
    baseUrl: baseUrl ?? void 0,
    accessToken: accessToken ?? null
  };
};

// src/runtime/wallet/local-eoa-connector.ts
var LocalEoaWalletConnector = class {
  constructor(options) {
    if (!options?.signer) {
      throw new Error("LocalEoaWalletConnector requires a signer instance");
    }
    this.signer = options.signer;
    this.metadata = {
      address: options.address ?? null,
      caip2: options.caip2 ?? null,
      chain: options.chain ?? null,
      chainType: options.chainType ?? null,
      provider: options.provider ?? "local",
      label: options.label ?? null
    };
  }
  async signChallenge(challenge) {
    const normalized = normalizeChallenge(challenge);
    const typedData = extractTypedDataPayload(normalized.payload);
    if (typedData) {
      if (!this.signer.signTypedData) {
        throw new Error(
          "Challenge payload requires typed-data signing but signer does not expose signTypedData()"
        );
      }
      const signature2 = await this.signer.signTypedData(typedData);
      await this.refreshMetadataFromSigner();
      return signature2;
    }
    const message = normalized.message ?? normalized.payloadHash;
    if (!message) {
      throw new Error(
        "Challenge payload does not include a signable message or payload hash"
      );
    }
    const signature = await this.signer.signMessage(
      coerceMessageForSigning(message)
    );
    await this.refreshMetadataFromSigner();
    return signature;
  }
  async getWalletMetadata() {
    if (!this.metadata?.address && this.signer.getAddress) {
      await this.refreshMetadataFromSigner();
    }
    return this.metadata;
  }
  async getAddress() {
    const metadata = await this.getWalletMetadata();
    return metadata?.address ?? null;
  }
  supportsCaip2(caip2) {
    if (!caip2) return false;
    if (!this.metadata?.caip2) return true;
    return this.metadata.caip2.toLowerCase() === caip2.toLowerCase();
  }
  async refreshMetadataFromSigner() {
    if (!this.signer.getAddress) {
      return;
    }
    try {
      const address = await this.signer.getAddress();
      if (!address) {
        return;
      }
      this.metadata = {
        ...this.metadata,
        address
      };
    } catch {
    }
  }
};
var coerceMessageForSigning = (message) => {
  const encoding = detectMessageEncoding(message);
  if (encoding === "utf-8") {
    return message;
  }
  const hex = message.slice(2);
  const bytes = new Uint8Array(hex.length / 2);
  for (let index = 0; index < hex.length; index += 2) {
    bytes[index / 2] = parseInt(hex.slice(index, index + 2), 16);
  }
  return bytes;
};
var extractTypedDataPayload = (payload) => {
  if (!payload || typeof payload !== "object") {
    return null;
  }
  const record = payload;
  const candidate = record.typed_data ?? record.typedData;
  if (!candidate || typeof candidate !== "object") {
    return null;
  }
  const typed = candidate;
  if (typeof typed.primary_type !== "string" || !typed.types || typeof typed.types !== "object" || !typed.domain || typeof typed.domain !== "object" || !typed.message || typeof typed.message !== "object") {
    return null;
  }
  return {
    primary_type: typed.primary_type,
    types: typed.types,
    domain: typed.domain,
    message: typed.message
  };
};

export { AgentApiClient, AgentApiClientError, AgentAuthClient, AgentAuthClientError, AgentRuntime, AgentRuntimeError, DEFAULT_API_BASE_URL, DEFAULT_CONFIG_FILENAME, ENV_AGENT_ID, ENV_AGENT_REF, ENV_BASE_URL, ENV_CONFIG_PATH, ENV_CREDENTIAL_ID, ENV_REFRESH_TOKEN, ENV_SCOPES, HttpTransportError, LocalEoaWalletConnector, MemoryStorageAdapter, ServerOrchestratorMissingAccessTokenError, ServerOrchestratorWalletConnector, TokenManager, TokenManagerError, createFetchTransport, createMemoryStorageAdapter, createUndiciTransport, createWallet, detectMessageEncoding, extractSignature, extractWalletMetadata, isHttpTransportError, loadAgentRuntimeConfig, normalizeChallenge, stableJsonStringify };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map