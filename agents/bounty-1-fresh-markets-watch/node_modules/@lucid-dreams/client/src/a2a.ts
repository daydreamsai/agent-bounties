// Thin client for the server's A2A hub endpoints

export type A2AMessagePart = { kind: "text"; text: string };
export type A2AMessage = {
  kind: "message";
  role: "user" | "agent";
  messageId: string;
  parts: A2AMessagePart[];
  taskId?: string;
  contextId?: string;
  metadata?: Record<string, unknown>;
};

export type A2ATaskState =
  | "submitted"
  | "working"
  | "input-required"
  | "completed"
  | "canceled"
  | "failed"
  | "unknown";

export type A2ATask = {
  kind: "task";
  id: string;
  contextId?: string;
  status?: { state: A2ATaskState; message?: A2AMessage; timestamp?: string };
  history?: A2AMessage[];
  metadata?: Record<string, unknown>;
  artifacts?: unknown[];
};

export type A2ATaskStatusUpdateEvent = {
  kind: "status-update";
  taskId: string;
  contextId?: string;
  status: { state: A2ATaskState; message?: A2AMessage; timestamp?: string };
  final?: boolean;
};

export type A2AAgentCard = {
  name: string;
  description?: string;
  url?: string;
  provider?: { organization?: string; url?: string };
  version?: string;
  capabilities?: {
    streaming?: boolean;
    pushNotifications?: boolean;
    stateTransitionHistory?: boolean;
  };
  defaultInputModes?: string[];
  defaultOutputModes?: string[];
  skills?: Array<{
    id: string;
    name?: string;
    description?: string;
    tags?: string[];
    examples?: string[];
    inputModes?: string[];
    outputModes?: string[];
    [key: string]: unknown;
  }>;
  supportsAuthenticatedExtendedCard?: boolean;
  // Vendor-neutral payments: currently supports x402 descriptors
  payments?: PaymentMethod[];
  [key: string]: unknown;
};

export type PaymentMethod = {
  method: "x402";
  // Human-readable string values for client-side display; no runtime coupling
  payee: string;
  network: string;
  endpoint?: string;
  priceModel?: { default?: string };
  extensions?: Record<string, unknown>;
};

type JsonRpcRequest = {
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: any;
};
type JsonRpcError = { code: number; message: string; data?: unknown };
type JsonRpcResponse<T = any> = {
  jsonrpc: "2.0";
  id: string | number | null;
  result?: T;
  error?: JsonRpcError;
};

export type A2ASendParams = {
  agentRef: string;
  skillId?: string;
  input?: any;
  message?: A2AMessage;
  configuration?: Record<string, unknown>;
  id?: string | number;
};

export type A2ASendStreamParams = {
  agentRef: string;
  skillId?: string;
  input?: any;
  message?: A2AMessage;
  configuration?: Record<string, unknown>;
  signal?: AbortSignal;
};

export class A2AHubClient {
  readonly baseUrl: string;
  private readonly defaultHeaders: HeadersInit;
  private readonly fetchImpl: typeof fetch;

  constructor(
    baseUrl: string,
    opts?: { headers?: HeadersInit; apiKey?: string; fetch?: typeof fetch }
  ) {
    this.baseUrl = baseUrl.replace(/\/+$/, "");
    const hdrs: HeadersInit = { "content-type": "application/json" };
    if (opts?.apiKey) (hdrs as any)["x-api-key"] = opts.apiKey;
    this.defaultHeaders = { ...hdrs, ...(opts?.headers || {}) };
    this.fetchImpl = opts?.fetch || fetch;
  }

  async getCard(agentRef: string): Promise<A2AAgentCard> {
    const url = `${this.baseUrl}/v1/agents/${encodeURIComponent(
      agentRef
    )}/a2a/card`;
    const r = await this.fetchImpl(url, {
      headers: { ...this.defaultHeaders, accept: "application/json" },
    });
    if (!r.ok) throw new Error(`getCard failed: ${r.status}`);
    return (await r.json()) as A2AAgentCard;
  }

  async sendMessage(params: A2ASendParams): Promise<A2ATask> {
    const id = params.id ?? crypto.randomUUID();
    const body: JsonRpcRequest = {
      jsonrpc: "2.0",
      id,
      method: "tasks/send",
      params: this.paramsFor(params),
    };
    const url = `${this.baseUrl}/v1/agents/${encodeURIComponent(
      params.agentRef
    )}/a2a/rpc`;
    const r = await this.fetchImpl(url, {
      method: "POST",
      headers: this.defaultHeaders,
      body: JSON.stringify(body),
    });
    const json = (await r.json().catch(() => ({}))) as JsonRpcResponse<A2ATask>;
    if (!r.ok || json.error)
      throw new Error(`RPC error: ${json.error?.message || r.statusText}`);
    if (!json.result) throw new Error("RPC result missing");
    return json.result;
  }

  // Async iterator of A2A events (Task, then status-update events) via SSE
  async *sendMessageStream(
    params: A2ASendStreamParams
  ): AsyncGenerator<A2ATask | A2ATaskStatusUpdateEvent, void, unknown> {
    const body: JsonRpcRequest = {
      jsonrpc: "2.0",
      id: crypto.randomUUID(),
      method: "tasks/sendSubscribe",
      params: this.paramsFor(params),
    };
    const url = `${this.baseUrl}/v1/agents/${encodeURIComponent(
      params.agentRef
    )}/a2a/rpc`;
    const controller = new AbortController();
    const signal = params.signal;
    const onAbort = () => controller.abort();
    if (signal) {
      if (signal.aborted) controller.abort();
      else signal.addEventListener("abort", onAbort, { once: true });
    }
    try {
      const r = await this.fetchImpl(url, {
        method: "POST",
        headers: { ...this.defaultHeaders, accept: "text/event-stream" },
        body: JSON.stringify(body),
        signal: controller.signal,
      });
      if (!r.ok || !r.body) throw new Error(`RPC stream failed: ${r.status}`);
      const reader = r.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        while (true) {
          const frameInfo = this.cutSSEFrame(buffer);
          if (!frameInfo) break;
          buffer = frameInfo.rest;
          const evt = this.parseSSEFrame(frameInfo.frame);
          if (evt && evt.event === "message") {
            try {
              const data = JSON.parse(evt.data || "null");
              if (data && data.jsonrpc === "2.0" && data.error)
                throw new Error(data.error.message || "stream_error");
              if (
                data &&
                (data.kind === "task" || data.kind === "status-update")
              ) {
                yield data as A2ATask | A2ATaskStatusUpdateEvent;
              }
            } catch (e) {
              // Propagate parse / rpc errors to consumer
              throw e;
            }
          }
        }
      }
      // Flush any trailing frame
      if (buffer.trim()) {
        const evt = this.parseSSEFrame(buffer);
        if (evt && evt.event === "message") {
          const data = JSON.parse(evt.data || "null");
          if (data && (data.kind === "task" || data.kind === "status-update")) {
            yield data as A2ATask | A2ATaskStatusUpdateEvent;
          }
        }
      }
    } finally {
      if (params.signal) params.signal.removeEventListener("abort", onAbort);
      controller.abort();
    }
  }

  private paramsFor(p: {
    skillId?: string;
    input?: any;
    message?: A2AMessage;
    configuration?: Record<string, unknown>;
  }) {
    const params: any = {};
    if (p.skillId) params.skillId = p.skillId;
    if (p.input) params.input = p.input;
    if (p.message) params.message = p.message;
    if (p.configuration) params.configuration = p.configuration;
    return params;
  }

  private cutSSEFrame(buf: string): { frame: string; rest: string } | null {
    const idxLF = buf.indexOf("\n\n");
    const idxCRLF = buf.indexOf("\r\n\r\n");
    let cut = -1;
    let skip = 0;
    if (idxLF !== -1 && (idxCRLF === -1 || idxLF < idxCRLF)) {
      cut = idxLF;
      skip = 2;
    } else if (idxCRLF !== -1) {
      cut = idxCRLF;
      skip = 4;
    }
    if (cut === -1) return null;
    return { frame: buf.slice(0, cut), rest: buf.slice(cut + skip) };
  }

  private parseSSEFrame(frame: string): { event: string; data: string } | null {
    const lines = frame.split(/\r?\n/);
    let event = "message";
    const dataParts: string[] = [];
    for (const raw of lines) {
      const line = raw.trimEnd();
      if (!line || line.startsWith(":")) continue;
      if (line.startsWith("event:")) event = line.slice(6).trim();
      else if (line.startsWith("data:"))
        dataParts.push(line.slice(5).trimStart());
    }
    return { event, data: dataParts.join("\n") };
  }
}
