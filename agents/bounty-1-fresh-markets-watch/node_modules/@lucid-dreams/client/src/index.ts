import { z } from "zod";

export const AgentSchema = z.object({
  id: z.string(),
  ref: z.string(),
  name: z.string(),
  description: z.string().nullable().optional(),
  // Stored as text in DB; not guaranteed to be a valid absolute URL
  baseUrl: z.string().nullable().optional(),
  billingAccountId: z.string().nullable().optional(),
  createdBy: z.string().nullable().optional(),
  ownerUserId: z.string().nullable().optional(),
  createdAt: z.union([z.string(), z.date()]).optional(),
  updatedAt: z.union([z.string(), z.date()]).optional(),
});

export const AgentCreateSchema = z.object({
  name: z.string().min(1),
  ref: z.string().min(1).optional(),
  description: z.string().optional(),
  base_url: z.string().min(1).optional(),
  billing_mode: z.enum(["user", "agent"]).optional(),
  billing_account_id: z.string().min(1).optional(),
});

export const AgentUpdateSchema = z.object({
  name: z.string().min(1).optional(),
  description: z.string().optional(),
  base_url: z.string().min(1).optional(),
});

export const AccountSummarySchema = z.object({
  id: z.string(),
  type: z.string(),
  displayName: z.string().nullable().optional(),
  defaultWalletId: z.string().nullable().optional(),
  createdBy: z.string().nullable().optional(),
  createdAt: z.union([z.string(), z.date()]).optional(),
  updatedAt: z.union([z.string(), z.date()]).optional(),
});

export const WalletAccountSchema = z.object({
  id: z.string(),
  accountId: z.string(),
  externalId: z.string().nullable().optional(),
  privyWalletId: z.string().nullable().optional(),
  provider: z.string().nullable().optional(),
  address: z.string().nullable().optional(),
  chain: z.string().nullable().optional(),
  chainType: z.string().nullable().optional(),
  status: z.string().nullable().optional(),
  type: z.string(),
  lastSyncedAt: z.union([z.string(), z.date()]).nullable().optional(),
  createdAt: z.union([z.string(), z.date()]).optional(),
  updatedAt: z.union([z.string(), z.date()]).optional(),
});

export const AgentBillingWarningSchema = z.object({
  code: z.string(),
  message: z.string(),
});

export const AgentBillingSchema = z.object({
  mode: z.enum(["user", "agent", "account"]),
  accountId: z.string(),
  account: AccountSummarySchema.optional(),
  wallet: WalletAccountSchema.nullable().optional(),
  warnings: z.array(AgentBillingWarningSchema).optional(),
});

export const AgentCreateResultSchema = z.object({
  agent: AgentSchema,
  billing: AgentBillingSchema,
});

const HexStringSchema = z
  .string()
  .regex(/^0x[a-fA-F0-9]*$/, "Must be a hex string with 0x prefix");

const AddressSchema = z
  .string()
  .regex(/^0x[a-fA-F0-9]{40}$/i, "Must be a valid EVM address");

const NumberLikeSchema = z.union([z.string(), z.number()]);

const EthereumTransactionRequestSchema = z
  .object({
    to: AddressSchema.optional(),
    from: AddressSchema.optional(),
    value: NumberLikeSchema.optional(),
    data: HexStringSchema.optional(),
    gas: NumberLikeSchema.optional(),
    gas_price: NumberLikeSchema.optional(),
    gasPrice: NumberLikeSchema.optional(),
    gas_limit: NumberLikeSchema.optional(),
    gasLimit: NumberLikeSchema.optional(),
    max_fee_per_gas: NumberLikeSchema.optional(),
    maxFeePerGas: NumberLikeSchema.optional(),
    max_priority_fee_per_gas: NumberLikeSchema.optional(),
    maxPriorityFeePerGas: NumberLikeSchema.optional(),
    nonce: NumberLikeSchema.optional(),
    chainId: NumberLikeSchema.optional(),
    chain_id: NumberLikeSchema.optional(),
    type: z
      .union([z.literal(0), z.literal(1), z.literal(2), NumberLikeSchema])
      .optional(),
  })
  .catchall(z.unknown());

const EthereumRpcParamsSchema = z
  .object({
    transaction: EthereumTransactionRequestSchema,
  })
  .catchall(z.unknown());

export const AgentWalletSendTransactionRequestSchema = z
  .object({
    caip2: z.string().min(1),
    idempotency_key: z.string().min(1).optional(),
    authorization_context: z.record(z.string(), z.unknown()).optional(),
    params: EthereumRpcParamsSchema,
  })
  .catchall(z.unknown());

export const AgentWalletSignTransactionRequestSchema =
  AgentWalletSendTransactionRequestSchema;

export const AgentWalletSignMessageRequestSchema = z
  .object({
    message: z.string().min(1),
    idempotency_key: z.string().min(1).optional(),
    authorization_context: z.record(z.string(), z.unknown()).optional(),
    encoding: z.enum(["utf-8", "hex"]).optional(),
  })
  .catchall(z.unknown());

const EthereumTransactionRequestResultSchema = z
  .object({
    chain_id: NumberLikeSchema.optional(),
    data: HexStringSchema.optional(),
    from: AddressSchema.optional(),
    gas_limit: NumberLikeSchema.optional(),
    gas_price: NumberLikeSchema.optional(),
    max_fee_per_gas: NumberLikeSchema.optional(),
    max_priority_fee_per_gas: NumberLikeSchema.optional(),
    nonce: NumberLikeSchema.optional(),
    to: AddressSchema.optional(),
    type: NumberLikeSchema.optional(),
    value: NumberLikeSchema.optional(),
  })
  .catchall(z.unknown());

const EthereumSendTransactionResultSchema = z.object({
  caip2: z.string(),
  hash: z.string(),
  transaction_id: z.string().optional(),
  transaction_request: EthereumTransactionRequestResultSchema.optional(),
});

const EthereumSignTransactionResultSchema = z.object({
  encoding: z.literal("rlp"),
  signed_transaction: HexStringSchema,
});

const EthereumSignMessageResultSchema = z.object({
  encoding: z.literal("hex"),
  signature: HexStringSchema,
});

const AgentWalletContextSchema = z.object({
  account: z.object({
    id: z.string(),
    displayName: z.string().nullable().optional(),
  }),
  wallet: z.object({
    id: z.string(),
    address: z.string().nullable().optional(),
    chainType: z.string(),
  }),
});

export const AgentWalletSendTransactionResponseSchema =
  AgentWalletContextSchema.extend({
    transaction: EthereumSendTransactionResultSchema,
  });

export const AgentWalletSignTransactionResponseSchema =
  AgentWalletContextSchema.extend({
    signed: EthereumSignTransactionResultSchema,
  });

export const AgentWalletSignMessageResponseSchema =
  AgentWalletContextSchema.extend({
    signed: EthereumSignMessageResultSchema,
  });

const EIP712TypeSchema = z.object({
  name: z.string(),
  type: z.string(),
});

const EIP712TypesSchema = z.record(z.string(), z.array(EIP712TypeSchema));

const EIP712DomainSchema = z.record(z.string(), z.unknown());

const EIP712MessageSchema = z.record(z.string(), z.unknown());

const EIP712TypedDataSchema = z.object({
  domain: EIP712DomainSchema,
  primary_type: z.string().min(1),
  types: EIP712TypesSchema,
  message: EIP712MessageSchema,
});

export const AgentWalletSignTypedDataRequestSchema = z
  .object({
    typed_data: EIP712TypedDataSchema,
    idempotency_key: z.string().min(1).optional(),
    authorization_context: z.record(z.string(), z.unknown()).optional(),
  })
  .catchall(z.unknown());

export const AgentWalletSignTypedDataResponseSchema =
  AgentWalletContextSchema.extend({
    signed: z.object({
      encoding: z.literal("hex"),
      signature: HexStringSchema,
    }),
  });

export const AgentTokenScopeSchema = z.enum(["wallet.sign", "wallet.send"]);

export const AgentTokenCreateRequestSchema = z
  .object({
    scopes: z.array(AgentTokenScopeSchema).min(1).optional(),
    description: z.string().max(200).optional(),
    expires_in_minutes: z.number().int().min(1).max(1440).optional(),
  })
  .catchall(z.unknown());

export const AgentTokenIssueResponseSchema = z.object({
  tokenId: z.string(),
  token: z.string(),
  expiresAt: z.union([z.string(), z.date()]),
  scopes: z.array(AgentTokenScopeSchema),
  description: z.string().nullable(),
});

export const AgentTokenSummarySchema = z.object({
  tokenId: z.string(),
  description: z.string().nullable(),
  scopes: z.array(AgentTokenScopeSchema),
  expiresAt: z.union([z.string(), z.date()]),
  createdAt: z.union([z.string(), z.date()]),
  lastUsedAt: z.union([z.string(), z.date()]).nullable(),
  revokedAt: z.union([z.string(), z.date()]).nullable(),
});

export const AgentRuntimeCredentialRequestSchema = z
  .object({
    credential_id: z.string().trim().min(1).optional(),
    scopes: z.array(AgentTokenScopeSchema).min(1).optional(),
  })
  .catchall(z.unknown());

export const AgentRuntimeCredentialResponseSchema = z.object({
  agentRef: z.string(),
  credentialId: z.string(),
  accessToken: z.string(),
  accessExpiresAt: z.union([z.string(), z.date()]),
  refreshToken: z.string(),
  refreshExpiresAt: z.union([z.string(), z.date()]),
  scopes: z.array(AgentTokenScopeSchema),
});

export const PricingSummarySchema = z.object({
  invoke: z.string().optional(),
  stream: z.string().optional(),
});
export type PricingSummary = z.infer<typeof PricingSummarySchema>;

export const AgentEntrypointSchema = z.object({
  key: z.string(),
  description: z.string().optional(),
  streaming: z.boolean().optional(),
  pricing: PricingSummarySchema.optional(),
});

export const InvokeRequestSchema = z.object({
  input: z.record(z.string(), z.unknown()),
  session_id: z.string().optional(),
  metadata: z.record(z.string(), z.unknown()).optional(),
  timeout_ms: z.number().int().positive().optional(),
});

export const InvokeResultSchema = z.object({
  run_id: z.string(),
  status: z.enum(["succeeded", "failed"]),
  output: z.record(z.string(), z.unknown()).optional(),
  error: z
    .object({
      code: z.string(),
      message: z.string(),
      details: z.record(z.string(), z.unknown()).optional(),
    })
    .optional(),
  usage: z
    .object({
      prompt_tokens: z.number().int().optional(),
      completion_tokens: z.number().int().optional(),
      total_tokens: z.number().int().optional(),
    })
    .optional(),
  model: z.string().optional(),
  timings: z.object({ total_ms: z.number().int().optional() }).optional(),
});

export const ApiErrorSchema = z.object({
  error: z.string(),
  message: z.string().optional(),
});

export type Agent = z.infer<typeof AgentSchema>;
export type AgentCreate = z.infer<typeof AgentCreateSchema>;
export type AgentUpdate = z.infer<typeof AgentUpdateSchema>;
export type AgentEntrypoint = z.infer<typeof AgentEntrypointSchema>;
export type InvokeRequest = z.infer<typeof InvokeRequestSchema>;
export type InvokeResult = z.infer<typeof InvokeResultSchema>;
export type ApiError = z.infer<typeof ApiErrorSchema>;
export type AccountSummary = z.infer<typeof AccountSummarySchema>;
export type WalletAccount = z.infer<typeof WalletAccountSchema>;
export type AgentBillingWarning = z.infer<typeof AgentBillingWarningSchema>;
export type AgentBilling = z.infer<typeof AgentBillingSchema>;
export type AgentCreateResult = z.infer<typeof AgentCreateResultSchema>;
export type AgentWalletSendTransactionRequest = z.infer<
  typeof AgentWalletSendTransactionRequestSchema
>;
export type AgentWalletSendTransactionResponse = z.infer<
  typeof AgentWalletSendTransactionResponseSchema
>;
export type AgentWalletSignTransactionRequest = z.infer<
  typeof AgentWalletSignTransactionRequestSchema
>;
export type AgentWalletSignTransactionResponse = z.infer<
  typeof AgentWalletSignTransactionResponseSchema
>;
export type AgentWalletSignMessageRequest = z.infer<
  typeof AgentWalletSignMessageRequestSchema
>;
export type AgentWalletSignMessageResponse = z.infer<
  typeof AgentWalletSignMessageResponseSchema
>;
export type AgentTokenScope = z.infer<typeof AgentTokenScopeSchema>;
export type AgentTokenCreateRequest = z.infer<
  typeof AgentTokenCreateRequestSchema
>;
export type AgentTokenIssueResponse = z.infer<
  typeof AgentTokenIssueResponseSchema
>;
export type AgentTokenSummary = z.infer<typeof AgentTokenSummarySchema>;
export type AgentRuntimeCredentialRequest = z.infer<
  typeof AgentRuntimeCredentialRequestSchema
>;
export type AgentRuntimeCredentialResponse = z.infer<
  typeof AgentRuntimeCredentialResponseSchema
>;
export type AgentWalletSignTypedDataRequest = z.infer<
  typeof AgentWalletSignTypedDataRequestSchema
>;
export type AgentWalletSignTypedDataResponse = z.infer<
  typeof AgentWalletSignTypedDataResponseSchema
>;

// Helper: list pagination
export const ListResponse = <T extends z.ZodTypeAny>(item: T) =>
  z.object({
    items: z.array(item),
    next_cursor: z.string().nullable().optional(),
  });

export type ListResponseType<T extends z.ZodTypeAny> = {
  items: Array<z.infer<T>>;
  next_cursor?: string | null;
};

// API response schemas
export const AgentsListResponseSchema = ListResponse(AgentSchema);
export type AgentsListResponse = z.infer<typeof AgentsListResponseSchema>;

export const AgentDetailResponseSchema = AgentSchema;
export type AgentDetailResponse = z.infer<typeof AgentDetailResponseSchema>;

export const EntrypointsListResponseSchema = z.object({
  source: z.enum(["cache", "live", "empty"]),
  items: z.array(AgentEntrypointSchema),
  manifest: z.unknown().optional(),
});
export type EntrypointsListResponse = z.infer<
  typeof EntrypointsListResponseSchema
>;

export const RefreshEntrypointsResponseSchema = z.object({
  source: z.literal("live"),
  items: z.array(AgentEntrypointSchema),
  manifest: z.unknown().optional(),
});
export type RefreshEntrypointsResponse = z.infer<
  typeof RefreshEntrypointsResponseSchema
>;

export const AgentRunSchema = z.object({
  runId: z.string(),
  agentRef: z.string(),
  status: z
    .enum(["queued", "running", "succeeded", "failed"])
    .or(z.literal("canceled"))
    .optional()
    .catch("queued"),
  inputJson: z.unknown().nullable().optional(),
  outputJson: z.unknown().nullable().optional(),
  promptTokens: z.number().int().nullable().optional(),
  completionTokens: z.number().int().nullable().optional(),
  totalTokens: z.number().int().nullable().optional(),
  model: z.string().nullable().optional(),
  totalMs: z.number().int().nullable().optional(),
  createdAt: z.union([z.string(), z.date()]).optional(),
  updatedAt: z.union([z.string(), z.date()]).optional(),
});
export type AgentRun = z.infer<typeof AgentRunSchema>;

const AgentGraphAmountSummarySchema = z.object({
  currency: z.string().nullable(),
  total: z.string().nullable(),
  raw: z.array(z.string()),
});
export type AgentGraphAmountSummary = z.infer<
  typeof AgentGraphAmountSummarySchema
>;

const AgentGraphLedgerStatusSummarySchema = z.object({
  count: z.number(),
  amounts: z.array(AgentGraphAmountSummarySchema),
});
export type AgentGraphLedgerStatusSummary = z.infer<
  typeof AgentGraphLedgerStatusSummarySchema
>;

const AgentGraphTotalsByStatusSchema = z.record(
  z.string(),
  z.array(AgentGraphAmountSummarySchema)
);

export const AgentGraphNodeSchema = z.object({
  id: z.string(),
  type: z.enum(["agent", "account", "user", "external"]),
  ref: z.string().nullable(),
  name: z.string().nullable(),
  label: z.string().nullable(),
  baseUrl: z.string().nullable(),
  stats: z.object({
    inboundRuns: z.number(),
    outboundRuns: z.number(),
    inboundStatusCounts: z.record(z.string(), z.number()),
    outboundStatusCounts: z.record(z.string(), z.number()),
    lastRunAt: z.string().nullable(),
  }),
  totals: z.object({
    spend: z.object({
      total: z.array(AgentGraphAmountSummarySchema),
      byStatus: AgentGraphTotalsByStatusSchema,
    }),
    earn: z.object({
      total: z.array(AgentGraphAmountSummarySchema),
      byStatus: AgentGraphTotalsByStatusSchema,
    }),
  }),
});
export type AgentGraphNode = z.infer<typeof AgentGraphNodeSchema>;

export const AgentGraphEdgeSchema = z.object({
  id: z.string(),
  from: z.string(),
  to: z.string(),
  fromType: z.enum(["agent", "account", "user", "external"]),
  toType: z.enum(["agent", "account", "user", "external"]),
  fromRef: z.string().nullable(),
  toRef: z.string().nullable(),
  runCount: z.number(),
  statusCounts: z.record(z.string(), z.number()),
  firstRunAt: z.string().nullable(),
  lastRunAt: z.string().nullable(),
  runIds: z.array(z.string()),
  sampleRunId: z.string().nullable(),
  ledger: z.object({
    totalCount: z.number(),
    statuses: z.record(z.string(), AgentGraphLedgerStatusSummarySchema),
    lastPayment: z
      .object({
        runId: z.string(),
        status: z.string(),
        amount: z.string().nullable(),
        currency: z.string().nullable(),
        updatedAt: z.string(),
      })
      .nullable(),
  }),
});
export type AgentGraphEdge = z.infer<typeof AgentGraphEdgeSchema>;

export const AgentGraphResponseSchema = z.object({
  window: z.object({
    from: z.string().nullable(),
    to: z.string().nullable(),
    runCount: z.number(),
    edgeCount: z.number(),
  }),
  nodes: z.array(AgentGraphNodeSchema),
  edges: z.array(AgentGraphEdgeSchema),
});
export type AgentGraphResponse = z.infer<typeof AgentGraphResponseSchema>;

export const RunsListResponseSchema = ListResponse(AgentRunSchema);
export type RunsListResponse = z.infer<typeof RunsListResponseSchema>;

export const HealthResponseSchema = z.object({
  ok: z.boolean(),
  mode: z.string(),
});
export type HealthResponse = z.infer<typeof HealthResponseSchema>;

export const EnqueueResponseSchema = z.object({
  run_id: z.string(),
  status: z.literal("queued"),
});
export type EnqueueResponse = z.infer<typeof EnqueueResponseSchema>;

// Run stream (SSE) events shared typing
export type RunStreamEventType = "open" | "update" | "error" | "end";
export type RunStreamEvent =
  | { type: "open"; data: { run_id: string } }
  | { type: "update"; data: { status: string } }
  | { type: "error"; data: { code: string; run_id?: string } }
  | { type: "end"; data: { status: string } };

// A2A hub client exports
export * from "./a2a";

// Paid client helper (x402-fetch)
export { createPaidA2AHubClient, type PaidClientOptions } from "./a2a-paid";
