type TrustModel = "feedback" | "inference-validation" | "tee-attestation" | string;
type RegistrationEntry = {
    agentId: number | string;
    agentAddress: string;
    signature?: string;
    [key: string]: unknown;
};
type TrustConfig = {
    registrations?: RegistrationEntry[];
    trustModels?: TrustModel[];
    validationRequestsUri?: string;
    validationResponsesUri?: string;
    feedbackDataUri?: string;
};

type Hex = `0x${string}`;
declare const ZERO_ADDRESS: Hex;
declare function normalizeDomain(domain: string): string;
declare function normalizeAddress(value: string | null | undefined): Hex;
declare function sanitizeAddress(value: string | null | undefined): Hex;
declare function toCaip10(params: {
    namespace?: string;
    chainId: number | string;
    address: string;
}): string;

type IdentityRegistryClientOptions<PublicClient extends PublicClientLike, WalletClient extends WalletClientLike | undefined = undefined> = {
    address: Hex;
    chainId?: number;
    publicClient: PublicClient;
    walletClient?: WalletClient;
    namespace?: string;
};
type IdentityRecord = {
    agentId: bigint;
    agentDomain: string;
    agentAddress: Hex;
};
type TrustOverridesInput = Partial<Pick<TrustConfig, "trustModels" | "validationRequestsUri" | "validationResponsesUri" | "feedbackDataUri">>;
type IdentityRegistryClient = {
    readonly address: Hex;
    readonly chainId?: number;
    get(agentId: bigint | number | string): Promise<IdentityRecord | null>;
    resolveByDomain(domain: string): Promise<IdentityRecord | null>;
    resolveByAddress(address: Hex): Promise<IdentityRecord | null>;
    register(input: RegisterAgentInput): Promise<RegisterAgentResult>;
    update(input: UpdateAgentInput): Promise<UpdateAgentResult>;
    toRegistrationEntry(record: IdentityRecord, signature?: string): RegistrationEntry;
};
type PublicClientLike = {
    readContract(args: {
        address: Hex;
        abi: typeof IDENTITY_REGISTRY_ABI;
        functionName: IdentityRegistryReadFunctionName;
        args?: readonly unknown[];
    }): Promise<any>;
};
type WalletClientLike = {
    account?: {
        address?: Hex;
    };
    writeContract(args: {
        address: Hex;
        abi: typeof IDENTITY_REGISTRY_ABI;
        functionName: IdentityRegistryWriteFunctionName;
        args?: readonly unknown[];
    }): Promise<Hex>;
};
type IdentityRegistryReadFunctionName = "Get" | "ResolveByDomain" | "ResolveByAddress";
type IdentityRegistryWriteFunctionName = "New" | "Update";
type RegisterAgentInput = {
    domain: string;
    agentAddress?: Hex;
};
type RegisterAgentResult = {
    transactionHash: Hex;
    agentAddress: Hex;
    agentId?: bigint;
};
type UpdateAgentInput = {
    agentId: bigint | number | string;
    domain?: string;
    agentAddress?: Hex;
};
type UpdateAgentResult = {
    transactionHash: Hex;
    agentId?: bigint;
};
declare const IDENTITY_REGISTRY_ABI: readonly [{
    readonly type: "function";
    readonly name: "New";
    readonly stateMutability: "nonpayable";
    readonly inputs: readonly [{
        readonly name: "agentDomain";
        readonly type: "string";
    }, {
        readonly name: "agentAddress";
        readonly type: "address";
    }];
    readonly outputs: readonly [{
        readonly name: "agentId";
        readonly type: "uint256";
    }];
}, {
    readonly type: "function";
    readonly name: "Update";
    readonly stateMutability: "nonpayable";
    readonly inputs: readonly [{
        readonly name: "agentId";
        readonly type: "uint256";
    }, {
        readonly name: "agentDomain";
        readonly type: "string";
    }, {
        readonly name: "agentAddress";
        readonly type: "address";
    }];
    readonly outputs: readonly [{
        readonly name: "ok";
        readonly type: "bool";
    }];
}, {
    readonly type: "function";
    readonly name: "Get";
    readonly stateMutability: "view";
    readonly inputs: readonly [{
        readonly name: "agentId";
        readonly type: "uint256";
    }];
    readonly outputs: readonly [{
        readonly name: "agentId";
        readonly type: "uint256";
    }, {
        readonly name: "agentDomain";
        readonly type: "string";
    }, {
        readonly name: "agentAddress";
        readonly type: "address";
    }];
}, {
    readonly type: "function";
    readonly name: "ResolveByDomain";
    readonly stateMutability: "view";
    readonly inputs: readonly [{
        readonly name: "agentDomain";
        readonly type: "string";
    }];
    readonly outputs: readonly [{
        readonly name: "agentId";
        readonly type: "uint256";
    }, {
        readonly name: "agentDomain";
        readonly type: "string";
    }, {
        readonly name: "agentAddress";
        readonly type: "address";
    }];
}, {
    readonly type: "function";
    readonly name: "ResolveByAddress";
    readonly stateMutability: "view";
    readonly inputs: readonly [{
        readonly name: "agentAddress";
        readonly type: "address";
    }];
    readonly outputs: readonly [{
        readonly name: "agentId";
        readonly type: "uint256";
    }, {
        readonly name: "agentDomain";
        readonly type: "string";
    }, {
        readonly name: "agentAddress";
        readonly type: "address";
    }];
}];
declare function createIdentityRegistryClient<PublicClient extends PublicClientLike, WalletClient extends WalletClientLike | undefined = undefined>(options: IdentityRegistryClientOptions<PublicClient, WalletClient>): IdentityRegistryClient;
type SignAgentDomainProofOptions = {
    domain: string;
    address: Hex;
    chainId: number;
    signer: MessageSignerLike;
    nonce?: string;
};
type MessageSignerLike = {
    signMessage(message: string): Promise<string>;
} | {
    signMessage(args: {
        message: string;
    }): Promise<string>;
} | {
    signMessage(message: unknown): Promise<string>;
};
declare function signAgentDomainProof(options: SignAgentDomainProofOptions): Promise<string>;
declare function buildTrustConfigFromIdentity(record: IdentityRecord, options?: {
    signature?: string;
    chainId: number | string;
    namespace?: string;
    trustOverrides?: TrustOverridesInput;
}): TrustConfig;
type BootstrapTrustMissingContext = {
    client: IdentityRegistryClient;
    normalizedDomain: string;
};
type BootstrapTrustOptions = {
    domain: string;
    chainId: number;
    registryAddress: Hex;
    publicClient: PublicClientLike;
    walletClient?: WalletClientLike;
    namespace?: string;
    signer?: MessageSignerLike;
    signatureNonce?: string;
    registerIfMissing?: boolean;
    skipRegister?: boolean;
    trustOverrides?: TrustOverridesInput;
    onMissing?: (context: BootstrapTrustMissingContext) => Promise<IdentityRecord | null | undefined> | IdentityRecord | null | undefined;
};
type BootstrapTrustResult = {
    trust?: TrustConfig;
    record?: IdentityRecord | null;
    transactionHash?: Hex;
    signature?: string;
    didRegister?: boolean;
};
declare function bootstrapTrust(options: BootstrapTrustOptions): Promise<BootstrapTrustResult>;
type InferLogger = {
    info?(message: string): void;
    warn?(message: string, error?: unknown): void;
};
type BootstrapIdentityClients = {
    publicClient: PublicClientLike;
    walletClient?: WalletClientLike;
    signer?: MessageSignerLike;
};
type BootstrapIdentityClientFactory = (params: {
    chainId: number;
    rpcUrl: string;
    env: Record<string, string | undefined>;
}) => BootstrapIdentityClients | null | undefined | Promise<BootstrapIdentityClients | null | undefined>;
type BootstrapIdentityOptions = {
    domain?: string;
    chainId?: number;
    registryAddress?: Hex;
    namespace?: string;
    publicClient?: PublicClientLike;
    walletClient?: WalletClientLike;
    signer?: MessageSignerLike;
    rpcUrl?: string;
    makeClients?: BootstrapIdentityClientFactory;
    registerIfMissing?: boolean;
    skipRegister?: boolean;
    signatureNonce?: string;
    trustOverrides?: TrustOverridesInput;
    fallback?: {
        address?: string;
        agentId?: number | string;
        namespace?: string;
        signature?: string;
        trustModels?: TrustConfig["trustModels"];
        validationRequestsUri?: string;
        validationResponsesUri?: string;
        feedbackDataUri?: string;
    };
    env?: Record<string, string | undefined>;
    logger?: InferLogger;
};
type BootstrapIdentityResult = BootstrapTrustResult & {
    synthetic?: boolean;
};
declare function bootstrapIdentity(options?: BootstrapIdentityOptions): Promise<BootstrapIdentityResult>;
type MakeViemClientsFromEnvOptions = {
    env?: Record<string, string | undefined>;
    rpcUrl?: string;
    privateKey?: `0x${string}` | string;
};
declare function makeViemClientsFromEnv(options?: MakeViemClientsFromEnvOptions): Promise<BootstrapIdentityClientFactory | undefined>;

export { type BootstrapIdentityClientFactory, type BootstrapIdentityClients, type BootstrapIdentityOptions, type BootstrapIdentityResult, type BootstrapTrustMissingContext, type BootstrapTrustOptions, type BootstrapTrustResult, type Hex, IDENTITY_REGISTRY_ABI, type IdentityRecord, type IdentityRegistryClient, type IdentityRegistryClientOptions, type MakeViemClientsFromEnvOptions, type MessageSignerLike, type PublicClientLike, type RegisterAgentInput, type RegisterAgentResult, type RegistrationEntry, type SignAgentDomainProofOptions, type TrustConfig, type TrustModel, type UpdateAgentInput, type UpdateAgentResult, type WalletClientLike, ZERO_ADDRESS, bootstrapIdentity, bootstrapTrust, buildTrustConfigFromIdentity, createIdentityRegistryClient, makeViemClientsFromEnv, normalizeAddress, normalizeDomain, sanitizeAddress, signAgentDomainProof, toCaip10 };
