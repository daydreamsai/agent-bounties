// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from "@tanstack/react-query";

import { client } from "../client.gen";
import {
  deleteV1AgentsByAgentRef,
  deleteV1AgentsByAgentRefCredentialsByCredentialId,
  deleteV1AgentsByAgentRefTokensByTokenId,
  getV1A2aRegistry,
  getV1Agents,
  getV1AgentsByAgentRef,
  getV1AgentsByAgentRefA2aCard,
  getV1AgentsByAgentRefCredentials,
  getV1AgentsByAgentRefEntrypoints,
  getV1AgentsByAgentRefHealth,
  getV1AgentsByAgentRefTokens,
  getV1AgentsGraph,
  getV1OnchainBalances,
  getV1OnrampBuyOptions,
  getV1Runs,
  getV1RunsByRunId,
  getV1RunsByRunIdLedger,
  getV1UsersMe,
  type Options,
  patchV1AgentsByAgentRef,
  postV1Agents,
  postV1AgentsByAgentRefA2aRpc,
  postV1AgentsByAgentRefCredentials,
  postV1AgentsByAgentRefEntrypointsByKeyInvoke,
  postV1AgentsByAgentRefEntrypointsByKeyRuns,
  postV1AgentsByAgentRefEntrypointsByKeyStream,
  postV1AgentsByAgentRefRefreshEntrypoints,
  postV1AgentsByAgentRefRuntimeCredentials,
  postV1AgentsByAgentRefTokens,
  postV1AgentsByAgentRefWalletSendTransaction,
  postV1AgentsByAgentRefWalletSignMessage,
  postV1AgentsByAgentRefWalletSignTransaction,
  postV1AgentsByAgentRefWalletSignTypedData,
  postV1AuthAgentsByAgentRefChallenge,
  postV1AuthAgentsByAgentRefExchange,
  postV1AuthAgentsByAgentRefRefresh,
  postV1AuthCoinbase,
  postV1AuthLogout,
  postV1AuthPrivy,
  postV1OnrampBuyQuote,
  postV1OnrampWebhook,
  postV1UsersMeWallets,
} from "../sdk.gen";
import type {
  DeleteV1AgentsByAgentRefCredentialsByCredentialIdData,
  DeleteV1AgentsByAgentRefCredentialsByCredentialIdError,
  DeleteV1AgentsByAgentRefCredentialsByCredentialIdResponse,
  DeleteV1AgentsByAgentRefData,
  DeleteV1AgentsByAgentRefError,
  DeleteV1AgentsByAgentRefResponse,
  DeleteV1AgentsByAgentRefTokensByTokenIdData,
  DeleteV1AgentsByAgentRefTokensByTokenIdError,
  DeleteV1AgentsByAgentRefTokensByTokenIdResponse,
  GetV1A2aRegistryData,
  GetV1A2aRegistryResponse,
  GetV1AgentsByAgentRefA2aCardData,
  GetV1AgentsByAgentRefCredentialsData,
  GetV1AgentsByAgentRefData,
  GetV1AgentsByAgentRefEntrypointsData,
  GetV1AgentsByAgentRefHealthData,
  GetV1AgentsByAgentRefTokensData,
  GetV1AgentsData,
  GetV1AgentsGraphData,
  GetV1OnchainBalancesData,
  GetV1OnrampBuyOptionsData,
  GetV1RunsByRunIdData,
  GetV1RunsByRunIdLedgerData,
  GetV1RunsData,
  GetV1UsersMeData,
  PatchV1AgentsByAgentRefData,
  PatchV1AgentsByAgentRefError,
  PatchV1AgentsByAgentRefResponse,
  PostV1AgentsByAgentRefA2aRpcData,
  PostV1AgentsByAgentRefA2aRpcError,
  PostV1AgentsByAgentRefA2aRpcResponse,
  PostV1AgentsByAgentRefCredentialsData,
  PostV1AgentsByAgentRefCredentialsError,
  PostV1AgentsByAgentRefCredentialsResponse,
  PostV1AgentsByAgentRefEntrypointsByKeyInvokeData,
  PostV1AgentsByAgentRefEntrypointsByKeyInvokeError,
  PostV1AgentsByAgentRefEntrypointsByKeyInvokeResponse,
  PostV1AgentsByAgentRefEntrypointsByKeyRunsData,
  PostV1AgentsByAgentRefEntrypointsByKeyRunsError,
  PostV1AgentsByAgentRefEntrypointsByKeyRunsResponse,
  PostV1AgentsByAgentRefEntrypointsByKeyStreamData,
  PostV1AgentsByAgentRefEntrypointsByKeyStreamError,
  PostV1AgentsByAgentRefEntrypointsByKeyStreamResponse,
  PostV1AgentsByAgentRefRefreshEntrypointsData,
  PostV1AgentsByAgentRefRefreshEntrypointsError,
  PostV1AgentsByAgentRefRefreshEntrypointsResponse,
  PostV1AgentsByAgentRefRuntimeCredentialsData,
  PostV1AgentsByAgentRefRuntimeCredentialsError,
  PostV1AgentsByAgentRefRuntimeCredentialsResponse,
  PostV1AgentsByAgentRefTokensData,
  PostV1AgentsByAgentRefTokensError,
  PostV1AgentsByAgentRefTokensResponse,
  PostV1AgentsByAgentRefWalletSendTransactionData,
  PostV1AgentsByAgentRefWalletSendTransactionError,
  PostV1AgentsByAgentRefWalletSendTransactionResponse,
  PostV1AgentsByAgentRefWalletSignMessageData,
  PostV1AgentsByAgentRefWalletSignMessageError,
  PostV1AgentsByAgentRefWalletSignMessageResponse,
  PostV1AgentsByAgentRefWalletSignTransactionData,
  PostV1AgentsByAgentRefWalletSignTransactionError,
  PostV1AgentsByAgentRefWalletSignTransactionResponse,
  PostV1AgentsByAgentRefWalletSignTypedDataData,
  PostV1AgentsByAgentRefWalletSignTypedDataError,
  PostV1AgentsByAgentRefWalletSignTypedDataResponse,
  PostV1AgentsData,
  PostV1AgentsError,
  PostV1AgentsResponse,
  PostV1AuthAgentsByAgentRefChallengeData,
  PostV1AuthAgentsByAgentRefChallengeError,
  PostV1AuthAgentsByAgentRefChallengeResponse,
  PostV1AuthAgentsByAgentRefExchangeData,
  PostV1AuthAgentsByAgentRefExchangeError,
  PostV1AuthAgentsByAgentRefExchangeResponse,
  PostV1AuthAgentsByAgentRefRefreshData,
  PostV1AuthAgentsByAgentRefRefreshError,
  PostV1AuthAgentsByAgentRefRefreshResponse,
  PostV1AuthCoinbaseData,
  PostV1AuthCoinbaseError,
  PostV1AuthCoinbaseResponse,
  PostV1AuthLogoutData,
  PostV1AuthLogoutError,
  PostV1AuthLogoutResponse,
  PostV1AuthPrivyData,
  PostV1AuthPrivyError,
  PostV1AuthPrivyResponse,
  PostV1OnrampBuyQuoteData,
  PostV1OnrampBuyQuoteError,
  PostV1OnrampWebhookData,
  PostV1OnrampWebhookError,
  PostV1OnrampWebhookResponse,
  PostV1UsersMeWalletsData,
  PostV1UsersMeWalletsError,
  PostV1UsersMeWalletsResponse,
} from "../types.gen";

/**
 * Exchange Privy token
 *
 * Exchange a Privy token for an authenticated session.
 */
export const postV1AuthPrivyMutation = (
  options?: Partial<Options<PostV1AuthPrivyData>>
): UseMutationOptions<
  PostV1AuthPrivyResponse,
  PostV1AuthPrivyError,
  Options<PostV1AuthPrivyData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AuthPrivyResponse,
    PostV1AuthPrivyError,
    Options<PostV1AuthPrivyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AuthPrivy({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Exchange Coinbase token
 *
 * Exchange a Coinbase access token for an authenticated session.
 */
export const postV1AuthCoinbaseMutation = (
  options?: Partial<Options<PostV1AuthCoinbaseData>>
): UseMutationOptions<
  PostV1AuthCoinbaseResponse,
  PostV1AuthCoinbaseError,
  Options<PostV1AuthCoinbaseData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AuthCoinbaseResponse,
    PostV1AuthCoinbaseError,
    Options<PostV1AuthCoinbaseData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AuthCoinbase({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Create agent auth challenge
 *
 * Create a challenge that an agent must sign to authenticate.
 */
export const postV1AuthAgentsByAgentRefChallengeMutation = (
  options?: Partial<Options<PostV1AuthAgentsByAgentRefChallengeData>>
): UseMutationOptions<
  PostV1AuthAgentsByAgentRefChallengeResponse,
  PostV1AuthAgentsByAgentRefChallengeError,
  Options<PostV1AuthAgentsByAgentRefChallengeData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AuthAgentsByAgentRefChallengeResponse,
    PostV1AuthAgentsByAgentRefChallengeError,
    Options<PostV1AuthAgentsByAgentRefChallengeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AuthAgentsByAgentRefChallenge({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Exchange agent challenge
 *
 * Exchange a signed challenge for agent access tokens.
 */
export const postV1AuthAgentsByAgentRefExchangeMutation = (
  options?: Partial<Options<PostV1AuthAgentsByAgentRefExchangeData>>
): UseMutationOptions<
  PostV1AuthAgentsByAgentRefExchangeResponse,
  PostV1AuthAgentsByAgentRefExchangeError,
  Options<PostV1AuthAgentsByAgentRefExchangeData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AuthAgentsByAgentRefExchangeResponse,
    PostV1AuthAgentsByAgentRefExchangeError,
    Options<PostV1AuthAgentsByAgentRefExchangeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AuthAgentsByAgentRefExchange({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Refresh agent access token
 *
 * Refresh an agent access token using a refresh token.
 */
export const postV1AuthAgentsByAgentRefRefreshMutation = (
  options?: Partial<Options<PostV1AuthAgentsByAgentRefRefreshData>>
): UseMutationOptions<
  PostV1AuthAgentsByAgentRefRefreshResponse,
  PostV1AuthAgentsByAgentRefRefreshError,
  Options<PostV1AuthAgentsByAgentRefRefreshData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AuthAgentsByAgentRefRefreshResponse,
    PostV1AuthAgentsByAgentRefRefreshError,
    Options<PostV1AuthAgentsByAgentRefRefreshData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AuthAgentsByAgentRefRefresh({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Logout
 *
 * Invalidate the current session token and clear cookies.
 */
export const postV1AuthLogoutMutation = (
  options?: Partial<Options<PostV1AuthLogoutData>>
): UseMutationOptions<
  PostV1AuthLogoutResponse,
  PostV1AuthLogoutError,
  Options<PostV1AuthLogoutData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AuthLogoutResponse,
    PostV1AuthLogoutError,
    Options<PostV1AuthLogoutData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AuthLogout({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  }
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl:
      options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const getV1AgentsQueryKey = (options?: Options<GetV1AgentsData>) =>
  createQueryKey("getV1Agents", options);

/**
 * List agents
 *
 * Retrieve up to 100 agents accessible to the current user.
 */
export const getV1AgentsOptions = (options?: Options<GetV1AgentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1Agents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1AgentsQueryKey(options),
  });
};

/**
 * Create agent
 *
 * Create a new agent with the provided configuration.
 */
export const postV1AgentsMutation = (
  options?: Partial<Options<PostV1AgentsData>>
): UseMutationOptions<
  PostV1AgentsResponse,
  PostV1AgentsError,
  Options<PostV1AgentsData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsResponse,
    PostV1AgentsError,
    Options<PostV1AgentsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1Agents({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1AgentsGraphQueryKey = (
  options?: Options<GetV1AgentsGraphData>
) => createQueryKey("getV1AgentsGraph", options);

/**
 * Agent run graph
 *
 * Fetch aggregate data about agent runs for visualization analytics.
 */
export const getV1AgentsGraphOptions = (
  options?: Options<GetV1AgentsGraphData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1AgentsGraph({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1AgentsGraphQueryKey(options),
  });
};

/**
 * Delete agent
 *
 * Delete an agent and its cached entrypoints.
 */
export const deleteV1AgentsByAgentRefMutation = (
  options?: Partial<Options<DeleteV1AgentsByAgentRefData>>
): UseMutationOptions<
  DeleteV1AgentsByAgentRefResponse,
  DeleteV1AgentsByAgentRefError,
  Options<DeleteV1AgentsByAgentRefData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteV1AgentsByAgentRefResponse,
    DeleteV1AgentsByAgentRefError,
    Options<DeleteV1AgentsByAgentRefData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteV1AgentsByAgentRef({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1AgentsByAgentRefQueryKey = (
  options: Options<GetV1AgentsByAgentRefData>
) => createQueryKey("getV1AgentsByAgentRef", options);

/**
 * Get agent details
 *
 * Fetch an agent along with its billing information.
 */
export const getV1AgentsByAgentRefOptions = (
  options: Options<GetV1AgentsByAgentRefData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1AgentsByAgentRef({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1AgentsByAgentRefQueryKey(options),
  });
};

/**
 * Update agent
 *
 * Update an existing agent.
 */
export const patchV1AgentsByAgentRefMutation = (
  options?: Partial<Options<PatchV1AgentsByAgentRefData>>
): UseMutationOptions<
  PatchV1AgentsByAgentRefResponse,
  PatchV1AgentsByAgentRefError,
  Options<PatchV1AgentsByAgentRefData>
> => {
  const mutationOptions: UseMutationOptions<
    PatchV1AgentsByAgentRefResponse,
    PatchV1AgentsByAgentRefError,
    Options<PatchV1AgentsByAgentRefData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await patchV1AgentsByAgentRef({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1AgentsByAgentRefHealthQueryKey = (
  options: Options<GetV1AgentsByAgentRefHealthData>
) => createQueryKey("getV1AgentsByAgentRefHealth", options);

/**
 * Check agent health
 *
 * Proxy request to the agent's health endpoint.
 */
export const getV1AgentsByAgentRefHealthOptions = (
  options: Options<GetV1AgentsByAgentRefHealthData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1AgentsByAgentRefHealth({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1AgentsByAgentRefHealthQueryKey(options),
  });
};

export const getV1AgentsByAgentRefEntrypointsQueryKey = (
  options: Options<GetV1AgentsByAgentRefEntrypointsData>
) => createQueryKey("getV1AgentsByAgentRefEntrypoints", options);

/**
 * List agent entrypoints
 *
 * List entrypoints for an agent, optionally refreshing from upstream.
 */
export const getV1AgentsByAgentRefEntrypointsOptions = (
  options: Options<GetV1AgentsByAgentRefEntrypointsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1AgentsByAgentRefEntrypoints({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1AgentsByAgentRefEntrypointsQueryKey(options),
  });
};

/**
 * Refresh agent entrypoints
 *
 * Force refresh an agent's entrypoints from upstream.
 */
export const postV1AgentsByAgentRefRefreshEntrypointsMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefRefreshEntrypointsData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefRefreshEntrypointsResponse,
  PostV1AgentsByAgentRefRefreshEntrypointsError,
  Options<PostV1AgentsByAgentRefRefreshEntrypointsData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefRefreshEntrypointsResponse,
    PostV1AgentsByAgentRefRefreshEntrypointsError,
    Options<PostV1AgentsByAgentRefRefreshEntrypointsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefRefreshEntrypoints({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1AgentsByAgentRefCredentialsQueryKey = (
  options: Options<GetV1AgentsByAgentRefCredentialsData>
) => createQueryKey("getV1AgentsByAgentRefCredentials", options);

/**
 * List agent credentials
 *
 * List credentials associated with an agent.
 */
export const getV1AgentsByAgentRefCredentialsOptions = (
  options: Options<GetV1AgentsByAgentRefCredentialsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1AgentsByAgentRefCredentials({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1AgentsByAgentRefCredentialsQueryKey(options),
  });
};

/**
 * Create agent credential
 *
 * Create a new credential for an agent.
 */
export const postV1AgentsByAgentRefCredentialsMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefCredentialsData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefCredentialsResponse,
  PostV1AgentsByAgentRefCredentialsError,
  Options<PostV1AgentsByAgentRefCredentialsData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefCredentialsResponse,
    PostV1AgentsByAgentRefCredentialsError,
    Options<PostV1AgentsByAgentRefCredentialsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefCredentials({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revoke agent credential
 *
 * Revoke a credential from an agent.
 */
export const deleteV1AgentsByAgentRefCredentialsByCredentialIdMutation = (
  options?: Partial<
    Options<DeleteV1AgentsByAgentRefCredentialsByCredentialIdData>
  >
): UseMutationOptions<
  DeleteV1AgentsByAgentRefCredentialsByCredentialIdResponse,
  DeleteV1AgentsByAgentRefCredentialsByCredentialIdError,
  Options<DeleteV1AgentsByAgentRefCredentialsByCredentialIdData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteV1AgentsByAgentRefCredentialsByCredentialIdResponse,
    DeleteV1AgentsByAgentRefCredentialsByCredentialIdError,
    Options<DeleteV1AgentsByAgentRefCredentialsByCredentialIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteV1AgentsByAgentRefCredentialsByCredentialId({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1AgentsByAgentRefTokensQueryKey = (
  options: Options<GetV1AgentsByAgentRefTokensData>
) => createQueryKey("getV1AgentsByAgentRefTokens", options);

/**
 * List agent tokens
 *
 * List API tokens issued for an agent.
 */
export const getV1AgentsByAgentRefTokensOptions = (
  options: Options<GetV1AgentsByAgentRefTokensData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1AgentsByAgentRefTokens({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1AgentsByAgentRefTokensQueryKey(options),
  });
};

/**
 * Create agent token
 *
 * Issue a new API token for an agent.
 */
export const postV1AgentsByAgentRefTokensMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefTokensData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefTokensResponse,
  PostV1AgentsByAgentRefTokensError,
  Options<PostV1AgentsByAgentRefTokensData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefTokensResponse,
    PostV1AgentsByAgentRefTokensError,
    Options<PostV1AgentsByAgentRefTokensData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefTokens({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Issue agent runtime credential
 *
 * Generate a refresh token backed by a managed wallet credential for use with the agent runtime.
 */
export const postV1AgentsByAgentRefRuntimeCredentialsMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefRuntimeCredentialsData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefRuntimeCredentialsResponse,
  PostV1AgentsByAgentRefRuntimeCredentialsError,
  Options<PostV1AgentsByAgentRefRuntimeCredentialsData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefRuntimeCredentialsResponse,
    PostV1AgentsByAgentRefRuntimeCredentialsError,
    Options<PostV1AgentsByAgentRefRuntimeCredentialsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefRuntimeCredentials({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revoke agent token
 *
 * Revoke an existing API token.
 */
export const deleteV1AgentsByAgentRefTokensByTokenIdMutation = (
  options?: Partial<Options<DeleteV1AgentsByAgentRefTokensByTokenIdData>>
): UseMutationOptions<
  DeleteV1AgentsByAgentRefTokensByTokenIdResponse,
  DeleteV1AgentsByAgentRefTokensByTokenIdError,
  Options<DeleteV1AgentsByAgentRefTokensByTokenIdData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteV1AgentsByAgentRefTokensByTokenIdResponse,
    DeleteV1AgentsByAgentRefTokensByTokenIdError,
    Options<DeleteV1AgentsByAgentRefTokensByTokenIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteV1AgentsByAgentRefTokensByTokenId({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Invoke agent entrypoint
 *
 * Trigger an agent entrypoint synchronously.
 */
export const postV1AgentsByAgentRefEntrypointsByKeyInvokeMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefEntrypointsByKeyInvokeData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefEntrypointsByKeyInvokeResponse,
  PostV1AgentsByAgentRefEntrypointsByKeyInvokeError,
  Options<PostV1AgentsByAgentRefEntrypointsByKeyInvokeData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefEntrypointsByKeyInvokeResponse,
    PostV1AgentsByAgentRefEntrypointsByKeyInvokeError,
    Options<PostV1AgentsByAgentRefEntrypointsByKeyInvokeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefEntrypointsByKeyInvoke({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Stream agent entrypoint
 *
 * Trigger an agent entrypoint and stream responses via SSE.
 */
// export const postV1AgentsByAgentRefEntrypointsByKeyStreamMutation = (
//   options?: Partial<Options<PostV1AgentsByAgentRefEntrypointsByKeyStreamData>>
// ): UseMutationOptions<
//   PostV1AgentsByAgentRefEntrypointsByKeyStreamResponse,
//   PostV1AgentsByAgentRefEntrypointsByKeyStreamError,
//   Options<PostV1AgentsByAgentRefEntrypointsByKeyStreamData>
// > => {
//   const mutationOptions: UseMutationOptions<
//     PostV1AgentsByAgentRefEntrypointsByKeyStreamResponse,
//     PostV1AgentsByAgentRefEntrypointsByKeyStreamError,
//     Options<PostV1AgentsByAgentRefEntrypointsByKeyStreamData>
//   > = {
//     mutationFn: async (fnOptions) => {
//       const { data } = await postV1AgentsByAgentRefEntrypointsByKeyStream({
//         ...options,
//         ...fnOptions,
//         throwOnError: true,
//       });
//       return data;
//     },
//   };
//   return mutationOptions;
// };

/**
 * Send transaction with agent wallet
 *
 * Send a transaction using the agent's managed wallet.
 */
export const postV1AgentsByAgentRefWalletSendTransactionMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefWalletSendTransactionData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefWalletSendTransactionResponse,
  PostV1AgentsByAgentRefWalletSendTransactionError,
  Options<PostV1AgentsByAgentRefWalletSendTransactionData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefWalletSendTransactionResponse,
    PostV1AgentsByAgentRefWalletSendTransactionError,
    Options<PostV1AgentsByAgentRefWalletSendTransactionData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefWalletSendTransaction({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Sign transaction with agent wallet
 *
 * Sign a transaction payload using the agent's managed wallet.
 */
export const postV1AgentsByAgentRefWalletSignTransactionMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefWalletSignTransactionData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefWalletSignTransactionResponse,
  PostV1AgentsByAgentRefWalletSignTransactionError,
  Options<PostV1AgentsByAgentRefWalletSignTransactionData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefWalletSignTransactionResponse,
    PostV1AgentsByAgentRefWalletSignTransactionError,
    Options<PostV1AgentsByAgentRefWalletSignTransactionData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefWalletSignTransaction({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Sign message with agent wallet
 *
 * Sign an arbitrary message using the agent's managed wallet.
 */
export const postV1AgentsByAgentRefWalletSignMessageMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefWalletSignMessageData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefWalletSignMessageResponse,
  PostV1AgentsByAgentRefWalletSignMessageError,
  Options<PostV1AgentsByAgentRefWalletSignMessageData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefWalletSignMessageResponse,
    PostV1AgentsByAgentRefWalletSignMessageError,
    Options<PostV1AgentsByAgentRefWalletSignMessageData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefWalletSignMessage({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Sign typed data with agent wallet
 *
 * Sign typed structured data via the agent's managed wallet.
 */
export const postV1AgentsByAgentRefWalletSignTypedDataMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefWalletSignTypedDataData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefWalletSignTypedDataResponse,
  PostV1AgentsByAgentRefWalletSignTypedDataError,
  Options<PostV1AgentsByAgentRefWalletSignTypedDataData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefWalletSignTypedDataResponse,
    PostV1AgentsByAgentRefWalletSignTypedDataError,
    Options<PostV1AgentsByAgentRefWalletSignTypedDataData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefWalletSignTypedData({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1AgentsByAgentRefA2aCardQueryKey = (
  options: Options<GetV1AgentsByAgentRefA2aCardData>
) => createQueryKey("getV1AgentsByAgentRefA2aCard", options);

/**
 * Get the A2A card for an agent
 *
 * This endpoint is used to get the A2A card for an agent.
 */
export const getV1AgentsByAgentRefA2aCardOptions = (
  options: Options<GetV1AgentsByAgentRefA2aCardData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1AgentsByAgentRefA2aCard({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1AgentsByAgentRefA2aCardQueryKey(options),
  });
};

/**
 * JSON-RPC endpoint for A2A tasks
 *
 * This endpoint is used to send and subscribe to A2A tasks.
 */
export const postV1AgentsByAgentRefA2aRpcMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefA2aRpcData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefA2aRpcResponse,
  PostV1AgentsByAgentRefA2aRpcError,
  Options<PostV1AgentsByAgentRefA2aRpcData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefA2aRpcResponse,
    PostV1AgentsByAgentRefA2aRpcError,
    Options<PostV1AgentsByAgentRefA2aRpcData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefA2aRpc({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1A2aRegistryQueryKey = (
  options?: Options<GetV1A2aRegistryData>
) => createQueryKey("getV1A2aRegistry", options);

/**
 * List agents in the A2A registry
 *
 * Return a paginated list of agent cards, optionally filtering by skill, streaming capability, or payment requirements.
 */
export const getV1A2aRegistryOptions = (
  options?: Options<GetV1A2aRegistryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1A2aRegistry({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1A2aRegistryQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const getV1A2aRegistryInfiniteQueryKey = (
  options?: Options<GetV1A2aRegistryData>
): QueryKey<Options<GetV1A2aRegistryData>> =>
  createQueryKey("getV1A2aRegistry", options, true);

/**
 * List agents in the A2A registry
 *
 * Return a paginated list of agent cards, optionally filtering by skill, streaming capability, or payment requirements.
 */
export const getV1A2aRegistryInfiniteOptions = (
  options?: Options<GetV1A2aRegistryData>
) => {
  return infiniteQueryOptions<
    GetV1A2aRegistryResponse,
    DefaultError,
    InfiniteData<GetV1A2aRegistryResponse>,
    QueryKey<Options<GetV1A2aRegistryData>>,
    | string
    | Pick<
        QueryKey<Options<GetV1A2aRegistryData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetV1A2aRegistryData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  cursor: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getV1A2aRegistry({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getV1A2aRegistryInfiniteQueryKey(options),
    }
  );
};

export const getV1UsersMeQueryKey = (options?: Options<GetV1UsersMeData>) =>
  createQueryKey("getV1UsersMe", options);

/**
 * Get current user
 *
 * Retrieve the authenticated user, session, and memberships.
 */
export const getV1UsersMeOptions = (options?: Options<GetV1UsersMeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1UsersMe({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1UsersMeQueryKey(options),
  });
};

/**
 * Create user wallet
 *
 * Create a managed wallet for the authenticated user on the specified chain.
 */
export const postV1UsersMeWalletsMutation = (
  options?: Partial<Options<PostV1UsersMeWalletsData>>
): UseMutationOptions<
  PostV1UsersMeWalletsResponse,
  PostV1UsersMeWalletsError,
  Options<PostV1UsersMeWalletsData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1UsersMeWalletsResponse,
    PostV1UsersMeWalletsError,
    Options<PostV1UsersMeWalletsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1UsersMeWallets({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1OnrampBuyOptionsQueryKey = (
  options: Options<GetV1OnrampBuyOptionsData>
) => createQueryKey("getV1OnrampBuyOptions", options);

/**
 * Fetch available Coinbase Onramp payment options.
 */
export const getV1OnrampBuyOptionsOptions = (
  options: Options<GetV1OnrampBuyOptionsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1OnrampBuyOptions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1OnrampBuyOptionsQueryKey(options),
  });
};

/**
 * Create a Coinbase Onramp buy quote.
 */
export const postV1OnrampBuyQuoteMutation = (
  options?: Partial<Options<PostV1OnrampBuyQuoteData>>
): UseMutationOptions<
  unknown,
  PostV1OnrampBuyQuoteError,
  Options<PostV1OnrampBuyQuoteData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    PostV1OnrampBuyQuoteError,
    Options<PostV1OnrampBuyQuoteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1OnrampBuyQuote({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Receive Coinbase Onramp webhook callbacks.
 *
 * Validates the Coinbase webhook signature and acknowledges receipt. Actual balance reconciliation is handled externally.
 */
export const postV1OnrampWebhookMutation = (
  options?: Partial<Options<PostV1OnrampWebhookData>>
): UseMutationOptions<
  PostV1OnrampWebhookResponse,
  PostV1OnrampWebhookError,
  Options<PostV1OnrampWebhookData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1OnrampWebhookResponse,
    PostV1OnrampWebhookError,
    Options<PostV1OnrampWebhookData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1OnrampWebhook({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1OnchainBalancesQueryKey = (
  options?: Options<GetV1OnchainBalancesData>
) => createQueryKey("getV1OnchainBalances", options);

/**
 * Get embedded wallet balances
 *
 * Returns cached onchain balances for the authenticated user's embedded Base and Solana wallets.
 */
export const getV1OnchainBalancesOptions = (
  options?: Options<GetV1OnchainBalancesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1OnchainBalances({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1OnchainBalancesQueryKey(options),
  });
};

/**
 * Invoke an agent entrypoint
 *
 * Enqueue a run for an agent entrypoint or execute it synchronously when wait=1.
 */
export const postV1AgentsByAgentRefEntrypointsByKeyRunsMutation = (
  options?: Partial<Options<PostV1AgentsByAgentRefEntrypointsByKeyRunsData>>
): UseMutationOptions<
  PostV1AgentsByAgentRefEntrypointsByKeyRunsResponse,
  PostV1AgentsByAgentRefEntrypointsByKeyRunsError,
  Options<PostV1AgentsByAgentRefEntrypointsByKeyRunsData>
> => {
  const mutationOptions: UseMutationOptions<
    PostV1AgentsByAgentRefEntrypointsByKeyRunsResponse,
    PostV1AgentsByAgentRefEntrypointsByKeyRunsError,
    Options<PostV1AgentsByAgentRefEntrypointsByKeyRunsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await postV1AgentsByAgentRefEntrypointsByKeyRuns({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getV1RunsQueryKey = (options?: Options<GetV1RunsData>) =>
  createQueryKey("getV1Runs", options);

/**
 * List runs
 *
 * List recent runs with optional filtering.
 */
export const getV1RunsOptions = (options?: Options<GetV1RunsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1Runs({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1RunsQueryKey(options),
  });
};

export const getV1RunsByRunIdQueryKey = (
  options: Options<GetV1RunsByRunIdData>
) => createQueryKey("getV1RunsByRunId", options);

/**
 * Get run detail
 *
 * Fetch detailed information about a run.
 */
export const getV1RunsByRunIdOptions = (
  options: Options<GetV1RunsByRunIdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1RunsByRunId({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1RunsByRunIdQueryKey(options),
  });
};

export const getV1RunsByRunIdLedgerQueryKey = (
  options: Options<GetV1RunsByRunIdLedgerData>
) => createQueryKey("getV1RunsByRunIdLedger", options);

/**
 * Run ledger entries
 *
 * Retrieve ledger entries associated with the run.
 */
export const getV1RunsByRunIdLedgerOptions = (
  options: Options<GetV1RunsByRunIdLedgerData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getV1RunsByRunIdLedger({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getV1RunsByRunIdLedgerQueryKey(options),
  });
};
